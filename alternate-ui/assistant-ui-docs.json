[
  {
    "title": "Deprecation Policy | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/migrations/deprecation-policy",
    "html": "Migrations\nDeprecation Policy\n\nassistant-ui is committed to providing a stable API, so you can spend your time building amazing things on top of it.\n\nRarely, we need to deprecate a feature we've already shipped, because it is causing performance, usability, or security issues. In such cases, we will communicate the intent to unship as soon as possible by marking the feature as @deprecated and publishing a notice in the documentation.\n\nDeprecations and breaking changes primarily affect new features released. The longer an API has been in the library, the less likely it is to be deprecated. For features that have long existed in the library, we will provide a longer deprecation notice period (as described below).\n\nBelow is a list of features considered stable and those considered experimental.\n\nExperimental Features\n\nThese features may be removed at any time without notice.\n\nAnything marked as unstable_, experimental_, or internal\nThe RuntimeCore API (considered internal)\nBeta Features\n\nA deprecation of these features will undergo a short (<1) month deprecation notice period.\n\nTailwindCSS Plugins (e.g. @assistant-ui/react/tailwindcss)\nContext API\nRuntime API\nMessage types\nStyled UI components\nPrimitive Hooks (e.g. useBranchPickerNext)\nAttachment APIs\nshadcn-ui styles\nStable Features\n\nA deprecation of these features will undergo a long (>3 month) deprecation notice period.\n\nThe following features are considered stable:\n\nPrimitives (except for AttachmentPrimitive)\n\nPrevious\n\nRuntime Layer\n\nNext\n\nMigration to v0.7"
  },
  {
    "title": "Markdown | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/ui/shadcn-ui/Markdown",
    "html": "shadcn-ui\nMarkdown\n\nAllow the assistant to display rich text using markdown.\n\nMarkdown support is alraedy included in the npx assistant-ui@latest add thread-full template.\n\nEnabling markdown support\nAdd the markdown-text component to your project.\nnpx assistant-ui@latest add markdown-text\nUse it in Thread.tsx\n\nPass the MarkdownText component to the MessagePrimitive.Content component\n\nimport { MarkdownText } from \"@/components/ui/assistant-ui/markdown-text\";\n \nconst AssistantMessage = () => {\n  return (\n    <MessagePrimitive.Root>\n      ...\n      <MessagePrimitive.Content components={{ Text: MarkdownText }} />\n      ...\n    </MessagePrimitive.Root>\n  );\n};\n\nPrevious\n\nAssistantSidebar\n\nNext\n\nCustom Scrollbar"
  },
  {
    "title": "AssistantSidebar | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/ui/shadcn-ui/AssistantSidebar",
    "html": "shadcn-ui\nAssistantSidebar\nOverview\n\nA chat sidebar show on the right side of the screen. Useful for co-pilot use cases.\n\nGetting Started\nInitialize shadcn-ui\nnpx shadcn@latest init\nAdd assistant-sidebar\nnpx assistant-ui@latest add sidebar\n\nThis adds /components/ui/assistant-ui/assistant-sidebar.tsx and /components/ui/assistant-ui/thread.tsx files to your project, which you can adjust as needed.\n\nUse in your application\n\n/app/page.tsx\n\nimport { AssistantSidebar } from \"@/components/ui/assistant-ui/assistant-sidebar\";\n \nexport default function Home() {\n  return (\n    <div className=\"h-full\">\n      <AssistantSidebar>{/* your app */}</AssistantSidebar>\n    </div>\n  );\n}\n\nPrevious\n\nAssistantModal\n\nNext\n\nMarkdown"
  },
  {
    "title": "AssistantModal | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/ui/shadcn-ui/AssistantModal",
    "html": "shadcn-ui\nAssistantModal\nOverview\n\nA chat bubble shown in the bottom right corner of the screen. Useful for support or Q&A use cases.\n\nGetting Started\nInitialize shadcn-ui\nnpx shadcn@latest init\nAdd assistant-modal\nnpx assistant-ui@latest add modal\n\nThis adds /components/ui/assistant-ui/assistant-modal.tsx and /components/ui/assistant-ui/thread.tsx files to your project, which you can adjust as needed.\n\nUse in your application\n\n/app/page.tsx\n\nimport { AssistantModal } from \"@/components/ui/assistant-ui/assistant-modal\";\n \nexport default function Home() {\n  return (\n    <div className=\"h-full\">\n      <AssistantModal />\n    </div>\n  );\n}\n\nPrevious\n\nThread\n\nNext\n\nAssistantSidebar"
  },
  {
    "title": "Migration to v0.7 | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/migrations/v0-7",
    "html": "Migrations\nMigration to v0.7\n\nThis guide serves as a reference for users facing breaking changes during upgrade to v0.7. You do not need to read this guide to upgrade to v0.7.\n\nAll breaking changes in v0.7 are renames or removals of existing APIs. Therefore, all breaking changes should cause a Typescript error, so you can simply check for errors after upgrading.\n\nComponent Property Types moved to Component.Props\n\nComponent property types are now neatly organized under the component itself.\n\n-import { ThreadPrimitiveMessagesProps } from \"@assistant-ui/react\";\n+import { ThreadPrimitive } from \"@assistant-ui/react\";\n \n-type Props = ThreadPrimitiveMessagesProps;\n+type Props = ThreadPrimitive.Messages.Props;\nContext API simplifications\nuseThreadContext, useMessageContext, ... replaced with direct imports of stores\n\nuseAssistantContext, useThreadContext, useMessageContext and useContentPartContext have been removed in favor of direct exports from @assistant-ui/react;\n\n-const { useThread } = useThreadContext();\n \n+import { useThread } from \"@assistant-ui/react\";\nAssistant Context API simplifications\nuseAssistantActions replaced with useAssistantRuntime\n\nuseAssistantActions has been removed in favor of useAssistantRuntime.\n\n-const switchToNewThread = useAssistantActions(a => a.switchToNewThread);\n+const runtime = useAssistantRuntime();\n+runtime.switchToNewThread();\nswitchToThread(null) replaced with switchToNewThread()\n-useThreadRuntime().switchToThread(null);\n+useThreadRuntime().switchToNewThread();\nuseSwtichToNewThread() moved to useAssistantRuntime().switchToNewThread()\n-useSwitchToNewThread();\n+const runtime = useAssistantRuntime()\n+runtime.switchToNewThread(); \nruntime.subscribe removed, subscribeToMainThread removed\n\nPreviously, you needed to subscribe to the runtime to receive updates whenever the main thread changed and resubscribe to the main thread whenever you switched to a new thread. The runtime.thread value now always refers to the current main thread, there is no need to subscribe to the runtime anymore.\n\nThreadRuntime API simplifications\nuseAppendMessage moved to useThreadRuntime().append()\n-const append = useAppendMessage();\n+const threadRuntime = useThreadRuntime();\n-append(\"hello world\");\n+threadRuntime.append(\"hello world\");\nuseThreadActions replaced with useThreadRuntime\n\nuseThreadActions has been removed in favor of useThreadRuntime.\n\n-const reload = useThreadActions(a => a.reload);\n+const threadRuntime = useThreadRuntime();\n+threadRuntime.reload();\nState values moved to threadRuntime.getState()\n\nIn order to make it clear that accessing the state only provides a snapshot of the current state and will not cause a re-render on changes, the state values of useThreadRuntime have been moved to threadRuntime.getState().\n\n-const isRunning = useThreadRuntime().isRunning; // anti-pattern, your code will not update on change\n+const isRunning = useThread(t => t.isRunning);\nuseThreadStore replaced with useThreadRuntime().getState()\n\nuseThreadStore has been removed in favor of useThreadRuntime().getState().\n\nthreadRuntime.getBranches() replaced with useThreadRuntime().getMessageByIndex(idx).getState().branchNumber/Count\n\nThe branch IDs are an internal implementation detail. The new Message Runtime API provides branchNumber and branchCount state fields that can be used instead.\n\nNew Message Runtime API replaces several methods from useThreadRuntime\n\nA few methods from useThreadRuntime have been moved to useMessageRuntime().\n\nthreadRuntime.switchToBranch() has been removed in favor of useThreadRuntime().getMessageByIndex(idx).switchToBranch().\nthreadRuntime.addToolResult() has been removed in favor of useThreadRuntime().getMessageByIndex(idx).getContentPartByToolCallId(toolCallId).addToolResult().\nthreadRuntime.speak() has been removed in favor of useThreadRuntime().getMessageByIndex(idx).speak().\nthreadRuntime.submitFeedback() has been removed in favor of useThreadRuntime().getMessageByIndex(idx).submitFeedback().\nthreadRuntime.getEditComposer() has been removed in favor of useThreadRuntime().getMessageById(id).getMessageByIndex(idx).composer.\nthreadRuntime.beginEdit() has been removed in favor of useThreadRuntime().getMessageById(id).getMessageByIndex(idx).composer.beginEdit().\nComposer Runtime API simplifications\nMethods inside useComposer moved to useComposerRuntime\n\nuseComposer() used to provide several methods such as setText, addAttachment, send, edit, cancel, ... These methods have been moved to useComposerRuntime().\n\nuseComposerStore replaced with useComposerRuntime().getState()\n\nuseComposerStore has been removed in favor of useComposerRuntime().getState().\n\nvalue setValue replaced with text setText\n-useComposer(c => c.value);\n+useComposer(c => c.text);\nfocus, onFocus methods removed\n\nThese methods have been removed.\n\nMessage Context API simplifications\nFlattened context values useMessage().message -> useMessage()\n\nMessageState is now itself a message, so you no longer need to access the nested useMessage().message field.\n\n-useMessage(m => m.message.content);\n+useMessage(m => m.content);\nuseMessageStore replaced with useMessageRuntime().getState()\n\nuseMessageStore has been removed in favor of useMessageRuntime().getState().\n\nContent Part Context API simplifications\nFlattened context values useContentPart().part -> useContentPart()\n\nContentPartState is now itself a content part, so you no longer need to access the nested useContentPart().part field.\n\n-useContentPart(c => c.part.type);\n+useContentPart(c => c.type);\n\nThis also applies to tool UI render functions:\n\n makeAssistantToolUI({\n   ...\n-  render: ({ part: { args } }) => <>{args}</>,\n+  render: ({ args }) => <>{args}</>,\n });\nAttachment Context API simplifications\nFlattened context values useAttachment().attachment -> useAttachment()\n\nAttachmentState is now itself an attachment, so you no longer need to access the nested useAttachment().attachment field.\n\n-useAttachment(a => a.attachment.type);\n+useAttachment(a => a.type);\nRoundtrips renamed to steps\n\nAssistantMessage.roundtrips was renamed to AssistantMessage.metadata.steps.\n\nEdge runtime's maxToolRoundtrips was replaced with maxSteps (which is maxToolRoundtrips + 1; if you had maxToolRoundtrips at 2, set maxSteps to 3).\n\nPrevious\n\nDeprecation Policy\n\nNext\n\nContentPart"
  },
  {
    "title": "Runtime Layer | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/concepts/runtime-layer",
    "html": "Concepts\nRuntime Layer\n\nassistant-ui components are full stack components. This means that they include both the UI presentation, but also logic to communicate with an external system. This logic is handled by the runtime layer and APIs.\n\nYou interact with the runtime layer in two ways:\n\ndefining a runtime for your app\nusing the runtime APIs to interact with the runtime\nDefining a runtime\n\nassistant-ui ships with two low-level runtimes:\n\nuseLocalRuntime\nuseExternalStoreRuntime\n\nBoth of these runtimes let you implement your own runtime. The conceptual difference between the two is that useLocalRuntime takes ownership of the data layer, while useExternalStoreRuntime does not.\n\nIf you have a stateful API to integrate, use useExternalStoreRuntime, if you have a stateless API to integrate, use useLocalRuntime.\n\nHigher level runtimes\n\nFor many services and APIs, assistant-ui provides deeper integrations. These are built with the two low-level runtimes mentioned above.\n\nuseEdgeRuntime: Connect to Vercel AI SDK backends or Edge Runtime backends\nuseVercelUseChatRuntime: Integrate with Vercel AI SDK's useChat hook\nuseVercelUseAssistantRuntime: Integrate with Vercel AI SDK's useAssistant hook (OpenAI Assistants API)\nuseVercelRSCRuntime: Integrate with Vercel AI SDK React Server Components\nuseLangGraphRuntime: Connect to LangGraph Cloud\nuseTrieveRuntime: Connect to Trieve.ai\n...\nRuntime Providers\n\nThe following components accept a runtime prop:\n\nAssistantRuntimeProvider\nThread\n\nThese components put the Runtime in the React Context, so that all child components can access the runtime.\n\nRuntime Adapters\n\nMost runtimes accept additional adapters to configure extra integrations:\n\nChatModelAdapter: Configures the backend API\nAttachmentAdapter: Configures the file/media attachment API\nSpeechSynthesisAdapter: Configures the speech API\nFeedbackAdapter: Configures the feedback API\nUsing the runtime APIs\n\nThe same API used by the assistant-ui components is also available to you. This allows you to build your own UI components and integrate them with the runtime layer.\n\nRuntime Hierarchy\n\nThe runtime API is nested as such:\n\nAssistantRuntime\nThreadListRuntime\nThreadRuntime\nMessageRuntime\nContentPartRuntime (Text / Image / Audio / Tool-Call / UI)\nMessageAttachmentRuntime\nEditComposerRuntime\nEditComposerAttachmentRuntime\nThreadComposerRuntime\nThreadComposerAttachmentRuntime\n\nThe AssistantRuntime (which encompasses everything), is sometimes simply called Runtime.\n\nRuntime Context Provider Components\n\nThe following components provide the runtime APIs:\n\n// provides AssistantRuntime, ThreadListRuntime, ThreadRuntime, ComposerRuntime (ThreadComposer)\n<AssistantRuntimeProvider runtime={runtime} />\n \n// renders every message, provides MessageRuntime, ComposerRuntime (EditComposer)\n<ThreadPrimitive.Messages components={{ Message, ... }} />\n \n// renders every content part, provides ContentPartRuntime\n<MessagePrimitive.Content components={{ Text, Image, Audio, UI, tools }} />\n \n// renders every attachment, provides AttachmentRuntime (Thread or EditComposer)\n<ComposerPrimitive.Attachments components={{ Attachment, ... }} />\n \n// renders every attachment, provides AtatchmentRuntime (Message)\n<MessagePrimitive.Attachments components={{ Attachment, ... }} />\n \n// provides a custom TextContentPartRuntime\n<TextContentPartProvider text=\"Hello!\" />\nAccessing runtime APIs\n\nYou can access the runtime APIs with react hooks:\n\nconst runtime = useAssistantRuntime();\nconst threadRuntime = useThreadRuntime();\nconst messageRuntime = useMessageRuntime();\nconst contentPartRuntime = useContentPartRuntime();\n \n// thread manager has no separate hook (1:1 relationship with assistant runtime)\nconst ThreadListRuntime = useAssistantRuntime().threadList;\n \n// composer runtime is multi-use\nconst composerRuntime = useComposerRuntime(); // refers to edit composer if available, otherwise thread composer\n \n// thread manager has no separate hook (1:1 relationship with assistant runtime)\nconst threadComposer = useThreadRuntime().composer;\n \n// thread manager has no separate hook (1:1 relationship with assistant runtime)\nconst editComposerRuntime = useMessageRuntime().composer;\n \n// attachment runtime is multi-use\nconst attachmentRuntime = useAttachmentRuntime(); // refers to the closest attachment runtime\nconst threadComposerAttachmentRuntime = useThreadComposerAttachmentRuntime();\nconst editComposerAttachmentRuntime = useEditComposerAttachmentRuntime();\nconst messageAttachmentRuntime = useMessageAttachmentRuntime();\nAccessing runtime state\n\nMost runtimes also expose a state through two methods getState and subscribe. The following helper hooks subscribe to the state, so that your component is updated when the state changes:\n\nuseThreadList(); // get thread manager state\nuseThread(); // get thread state\nuseMessage(); // get message state\nuseContentPart(); // get content part state\nuseComposer(); // get composer state\nuseThreadComposer(); // get thread composer state\nuseEditComposer(); // get edit composer state\nuseAttachment(); // get attachment state\nuseThreadComposerAttachment(); // get thread composer attachment state\nuseEditComposerAttachment(); // get edit composer attachment state\nuseMessageAttachment(); // get message attachment state\n\nYou might not want to subscribe to evey update. In that case, pass a callback selector to the hook:\n\n// only subscribe to role changes\nconst role = useMessage((state) => message.role);\n\nPrevious\n\nArchitecture\n\nNext\n\nDeprecation Policy"
  },
  {
    "title": "Custom Scrollbar | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/ui/shadcn-ui/Scrollbar",
    "html": "shadcn-ui\nCustom Scrollbar\n\nIf you want to show a custom scrollbar UI of the Thread.Viewport in place of the system default, you can integrate @radix-ui/react-scroll-area. An example implementation of this is shadcn-ui's Scroll Area.\n\nAdd shadcn Scroll Area\nnpx shadcn@latest add scroll-area\n@radix-ui/react-scroll-area v1.2.0 release candidate required\n\nThe v1.2.0-rc.x release candidate can be installed via\n\npnpm add @radix-ui/react-scroll-area@next\nAdditional Styles\n\nThe radix-ui Viewport component adds an intermediate <div data-radix-scroll-area-content> element. Add the following CSS to your globals.css:\n\n@/app/globals.css\n.thread-viewport > [data-radix-scroll-area-content] {\n  @apply flex flex-col items-center self-stretch bg-inherit;\n}\nIntegration\nWrap Thread.Root with <ScrollAreaPrimitive.Root asChild>\nWrap Thread.Viewport with <ScrollAreaPrimitive.Viewport className=\"thread-viewport\" asChild>\nAdd shadcn's <ScrollBar /> to Thread.Root\n\nThe resulting MyThread component should look like this:\n\nimport * as ScrollAreaPrimitive from \"@radix-ui/react-scroll-area\";\nimport { ScrollBar } from \"@/components/ui/scroll-area\";\n \nconst MyThread: FC = () => {\n  return (\n    <ScrollAreaPrimitive.Root asChild>\n      <ThreadPrimitive.Root className=\"...\">\n        <ScrollAreaPrimitive.Viewport className=\"thread-viewport\" asChild>\n          <ThreadPrimitive.Viewport className=\"...\">\n            ...\n          </ThreadPrimitive.Viewport>\n        </ScrollAreaPrimitive.Viewport>\n        <ScrollBar />\n      </ThreadPrimitive.Root>\n    </ScrollAreaPrimitive.Root>\n  );\n};\n\nPrevious\n\nMarkdown\n\nNext\n\nComposition"
  },
  {
    "title": "Thread | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/ui/shadcn-ui/Thread",
    "html": "shadcn-ui\nThread\nOverview\n\nThe raw message list and message composer UI. Useful for full screen chat use cases.\n\nGetting Started\nInitialize shadcn-ui\nnpx shadcn@latest init\nAdd thread\nnpx assistant-ui@latest add thread\n\nThis adds a /components/ui/assistant-ui/thread.tsx file to your project, which you can adjust as needed.\n\nThe thread template is minimal and does not include branching or editing support.\n\nAlternatively, you can add thread-full, which includes branching and editing enabled by default.\n\nnpx assistant-ui@latest add thread-full\nUse in your application\n\n/app/page.tsx\n\nimport { Thread } from \"@/components/ui/assistant-ui/thread\";\n \nexport default function Home() {\n  return (\n    <div className=\"h-full\">\n      <Thread />\n    </div>\n  );\n}\n\nPrevious\n\nCustom Scrollbar\n\nNext\n\nAssistantModal"
  },
  {
    "title": "@assistant-ui/react-hook-form | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/reference/integrations/react-hook-form",
    "html": "Reference\nIntegrations\n@assistant-ui/react-hook-form\n\nA React Hook Form integration for @assistant-ui.\n\nAPI Reference\nuseAssistantForm\n\nDrop-in replacement hook for useForm that adds support for @assistant-ui/react.\n\n- import { useForm } from \"react-hook-form\";\n+ import { useAssistantForm } from \"@assistant-ui/react-hook-form\";\n \n- useForm({\n+ useAssistantForm({\n    ...\n  });\nProperties\nUseAssistantFormProps\nassistant?:\nobject\n\nConfiguration for useAssistantForm\n\ntools?:\nobject\n\nTools configuration for useAssistantForm\n\nset_form_field?:\nobject\n\nConfiguration for the set_form_field tool\n\nrender?:\nToolCallContentPartComponent<{ name: string; value: string; }, {}>\n\nThe component to render when set_form_field is called.\n\nsubmit_form?:\nobject\n\nConfiguration for the submit_form tool\n\nrender?:\nToolCallContentPartComponent<{}, {}>\n\nThe component to render when submit_form is called.\n\nformTools\n\nThe set of tools to use with useAssistantForm, useful for runtimes that do not support client-side tool definitions (i.e. Vercel AI SDK).\n\nimport { formTools } from \"@assistant-ui/react-hook-form\";\n \nconst result = streamText({\n  ...\n  tools: {\n    ...formTools,\n  }\n});\n\nPrevious\n\n@assistant-ui/react-ai-sdk\n\nNext\n\n<AssistantRuntimeProvider />"
  },
  {
    "title": "@assistant-ui/react-ai-sdk | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/reference/integrations/vercel-ai-sdk",
    "html": "Reference\nIntegrations\n@assistant-ui/react-ai-sdk\n\nVercel AI SDK integration for assistant-ui.\n\nAPI Reference\nuseVercelUseChatRuntime\n\nConvert Vercel AI SDK chat helpers into a AssistantRuntime.\n\nimport { useVercelUseChatRuntime } from \"@assistant-ui/react-ai-sdk\";\n \nconst MyRuntimeProvider = ({ children }: { children: React.ReactNode }) => {\n  const chat = useChat();\n  const runtime = useVercelUseChatRuntime(chat);\n \n  return (\n    <AssistantRuntimeProvider runtime={runtime}>\n      {children}\n    </AssistantRuntimeProvider>\n  );\n};\nchat?:\nReturnType<typeof useChat>\n\nThe UseChatHelpers from ai/react.\n\nuseVercelUseAssistantRuntime\n\nConvert Vercel AI SDK assistant helpers into a AssistantRuntime.\n\nimport { useVercelUseAssistantRuntime } from \"@assistant-ui/react-ai-sdk\";\n \nconst MyRuntimeProvider = ({ children }: { children: React.ReactNode }) => {\n  const assistant = useAssistant();\n  const runtime = useVercelUseAssistantRuntime(assistant);\n \n  return (\n    <AssistantRuntimeProvider runtime={runtime}>\n      {children}\n    </AssistantRuntimeProvider>\n  );\n};\nassistant?:\nReturnType<typeof useAssistant>\n\nThe UseAssistantHelpers from ai/react.\n\nuseVercelRSCRuntime\n\nConvert Vercel RSC runtime into a AssistantRuntime.\n\nimport { useVercelRSCRuntime } from \"@assistant-ui/react-ai-sdk\";\n \nconst MyRuntimeProvider = ({ children }: { children: React.ReactNode }) => {\n  const [messages, setMessages] = useUIState<typeof AI>();\n \n  const onNew = async (m: AppendMessage) => {\n    if (m.content[0]?.type !== \"text\")\n      throw new Error(\"Only text messages are supported\");\n \n    const input = m.content[0].text;\n    setMessages((currentConversation) => [\n      ...currentConversation,\n      { id: nanoid(), role: \"user\", display: input },\n    ]);\n \n    const message = await continueConversation(input);\n \n    setMessages((currentConversation) => [...currentConversation, message]);\n  };\n \n  const runtime = useVercelRSCRuntime({ messages, onNew });\n \n  return (\n    <AssistantRuntimeProvider runtime={runtime}>\n      {children}\n    </AssistantRuntimeProvider>\n  );\n};\nadapter?:\nVercelRSCAdapter<TMessage>\n\nThe Vercel RSC adapter to use.\n\nVercelRSCAdapter<TMessage>\nmessages?:\nreadonly ThreadMessage[]\n\nThe messages in the thread.\n\nonNew?:\n(message: AppendMessage) => Promise<void>\n\nA function to append a message to the thread.\n\nonEdit?:\n(message: AppendMessage) => Promise<void>\n\nA function to edit a message.\n\nonReload?:\n(parentId: string | null) => Promise<void>\n\nA function to reload a message.\n\nconvertMessage?:\n(message: TMessage) => VercelRSCMessage\n\nA function to convert messages to the VercelRSCMessage format. Only required if your message objects are not already compatible with Vercel RSC.\n\nPrevious\n\nRuntime API\n\nNext\n\n@assistant-ui/react-hook-form"
  },
  {
    "title": "ContentPart | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/components/content-part",
    "html": "Components\nContentPart\n\nEach message can have any number of content parts. Content parts are usually one of text, audio or tool-call. Additionally, image and file content parts are available, but rarely used, since these are usually included as content parts of message attachments.\n\nStyled Components\n\nPlain text is usually used for user messages. Markdown text is usually used for assistant messages.\n\nPlain Text\nimport { ContentPart } from \"@assistant/react\";\n \n<ContentPart.Text />;\nMarkdown Text\nimport { makeMarkdownText } from \"@assistant-ui/react-markdown\";\n \nconst MarkdownText = makeMarkdownText();\n \n<MarkdownText />;\nThread Config\n\nThe <Thread /> compoonent allows customization of content part UI in the following ways:\n\n<Thread\n  tools={[MyToolUI]}\n  assistantMessage={{\n    components: { Text: MarkdownText, ToolFallback: MyToolFallback }\n  }}\n/>\nPrimitives\nPlain Text\nimport { ContentPartPrimitive } from \"@assistant/react\";\n \n<ContentPartPrimitive.Text />;\nMarkdown Text\nimport { MarkdownTextPrimitive } from \"@assistant-ui/react-markdown\";\n \nconst MarkdownTextPrimitive = makeMarkdownTextPrimitive();\n \n<MarkdownTextPrimitive />;\nContext Provider\n\nContent part context is provided by MessagePrimitive.Content or TextContentPartProvider\n\nMessagePrimitive.Content\nimport { MessagePrimitive } from \"@assistant/react\";\n \n<MessagePrimitive.Content\n  components={{\n    Text: MyText,\n    Audio: MyAudio,\n    tools: {\n      by_name: {\n        get_weather: MyWeatherToolUI,\n      },\n      Fallback: MyFallbackToolUI,\n    },\n  }}\n/>;\nTextContentPartProvider\n\nThis is a helper context provider to allow you to reuse the content part components outside of a message content part.\n\nimport { TextContentPartProvider } from \"@assistant/react\";\n \n<TextContentPartProvider text=\"Hello world\" isRunning={false}>\n  <ContentPart.Text />\n</TextContentPartProvider>;\nRuntime API\nuseContentPartRuntime\nimport { useContentPartRuntime } from \"@assistant/react\";\n \nconst contentPartRuntime = useContentPartRuntime();\nContentPartRuntime\naddToolResult:\n(result: any) => void\n\nAdd tool result to a tool call content part that has no tool result yet. This is useful when you are collecting a tool result via user input (\"human tool calls\").\n\npath:\nContentPartRuntimePath\n\ngetState:\n() => ContentPartState\n\nsubscribe:\n(callback: () => void) => Unsubscribe\n\nuseContentPart\nimport { useContentPart } from \"@assistant/react\";\n \nconst contentPart = useContentPart();\nTextContentPartState\ntype:\n\"text\"\n\ntext:\nstring\n\nstatus:\n{ readonly type: \"running\"; } | { readonly type: \"complete\"; } | { readonly type: \"incomplete\"; readonly reason: \"length\" | \"cancelled\" | \"content-filter\" | \"other\" | \"error\"; readonly error?: unknown; } | { readonly type: \"requires-action\"; readonly reason: \"tool-calls\"; }\n\nAudioContentPartState\ntype:\n\"audio\"\n\naudio:\n{ readonly data: string; readonly format: \"mp3\" | \"wav\"; }\n\nstatus:\n{ readonly type: \"running\"; } | { readonly type: \"complete\"; } | { readonly type: \"incomplete\"; readonly reason: \"length\" | \"cancelled\" | \"content-filter\" | \"other\" | \"error\"; readonly error?: unknown; } | { readonly type: \"requires-action\"; readonly reason: \"tool-calls\"; }\n\nImageContentPartState\ntype:\n\"image\"\n\nimage:\nstring\n\nstatus:\n{ readonly type: \"running\"; } | { readonly type: \"complete\"; } | { readonly type: \"incomplete\"; readonly reason: \"length\" | \"cancelled\" | \"content-filter\" | \"other\" | \"error\"; readonly error?: unknown; } | { readonly type: \"requires-action\"; readonly reason: \"tool-calls\"; }\n\nUIContentPartState\ntype:\n\"ui\"\n\ndisplay:\nReact.ReactNode\n\nstatus:\n{ readonly type: \"running\"; } | { readonly type: \"complete\"; } | { readonly type: \"incomplete\"; readonly reason: \"length\" | \"cancelled\" | \"content-filter\" | \"other\" | \"error\"; readonly error?: unknown; } | { readonly type: \"requires-action\"; readonly reason: \"tool-calls\"; }\n\nToolCallContentPartState\ntype:\n\"tool-call\"\n\ntoolCallId:\nstring\n\ntoolName:\nstring\n\nargs:\nRecord<string | number, unknown>\n\nresult?:\nunknown\n\nisError?:\nboolean | undefined\n\nargsText:\nstring\n\nstatus:\n{ readonly type: \"running\"; } | { readonly type: \"complete\"; } | { readonly type: \"incomplete\"; readonly reason: \"length\" | \"cancelled\" | \"content-filter\" | \"other\" | \"error\"; readonly error?: unknown; } | { readonly type: \"requires-action\"; readonly reason: \"tool-calls\"; }\n\nuseContentPartText\nimport { useContentPartText } from \"@assistant/react\";\n \nconst contentPartText = useContentPartText();\nTextContentPartState\ntype:\n\"text\"\n\ntext:\nstring\n\nstatus:\n{ readonly type: \"running\"; } | { readonly type: \"complete\"; } | { readonly type: \"incomplete\"; readonly reason: \"length\" | \"cancelled\" | \"content-filter\" | \"other\" | \"error\"; readonly error?: unknown; } | { readonly type: \"requires-action\"; readonly reason: \"tool-calls\"; }\n\nPrevious\n\nMigration to v0.7\n\nNext\n\nRuntime API"
  },
  {
    "title": "Part 2: Generative UI | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/runtimes/langgraph/tutorial/part-2",
    "html": "LangGraph Cloud\nTutorial: Stockbroker\nPart 2: Generative UI\n\nIn the previous step, we set up the frontend to connect to a LangGraph Cloud endpoint.\n\nIn this step, we will set up a component to display stock ticker information.\n\nFor reference, this the corresponding code in the backend:\n\nhttps://github.com/Yonom/assistant-ui-stockbroker/blob/main/backend/src/tools.ts#L193C1-L216C3\n\nassistant-ui-stockbroker/backend/tools/PriceSnapshotTool.ts\nexport const priceSnapshotTool = tool(\n  async (input) => {\n    const data = await callFinancialDatasetAPI<SnapshotResponse>({\n      endpoint: \"/prices/snapshot\",\n      params: {\n        ticker: input.ticker,\n      },\n    });\n    return JSON.stringify(data, null);\n  },\n  {\n    name: \"price_snapshot\",\n    description:\n      \"Retrieves the current stock price and related market data for a given company.\",\n    schema: z.object({\n      ticker: z.string().describe(\"The ticker of the company. Example: 'AAPL'\"),\n    }),\n  },\n);\nPriceSnapshotTool\n\nWe create a new file under /components/tools/price-snapshot/PriceSnapshotTool.tsx to define the tool.\n\nFirst, we define the tool arguments and result types:\n\n@/components/tools/price-snapshot/PriceSnapshotTool.tsx\ntype PriceSnapshotToolArgs = {\n  ticker: string;\n};\n \ntype PriceSnapshotToolResult = {\n  snapshot: {\n    price: number;\n    day_change: number;\n    day_change_percent: number;\n    time: string;\n  };\n};\n\nThen, we use makeAssistantToolUI to define the tool UI:\n\n@/components/tools/price-snapshot/PriceSnapshotTool.tsx\n\"use client\";\n \nimport { makeAssistantToolUI } from \"@assistant-ui/react\";\n \nexport const PriceSnapshotTool = makeAssistantToolUI<\n  PriceSnapshotToolArgs,\n  string\n>({\n  toolName: \"price_snapshot\",\n  render: function PriceSnapshotUI({ args, result }) {\n    return (\n      <div className=\"mb-4 flex flex-col items-center\">\n        <pre className=\"whitespace-pre-wrap break-all text-center\">\n          price_snapshot({JSON.stringify(args)})\n        </pre>\n      </div>\n    );\n  },\n});\n\nThis simply displays the tool name and arguments passed to it, but not the result.\n\nBind tool UI\n@/app/page.tsx\nimport { PriceSnapshotTool } from \"@/components/tools/price-snapshot/PriceSnapshotTool\";\n \nexport default function Home() {\n  return (\n    <div className=\"flex h-full flex-col\">\n      <Thread\n        ...\n        tools={[PriceSnapshotTool]}\n      />\n    </div>\n  );\n}\nTry it out!\n\nAsk the assistant for the current stock price of Tesla. You should see the following text appear:\n\nprice_snapshot({ticker: \"TSLA\"})\n\nNext, we will visualize the function's result.\n\nVisualizing tool results\nInstall dependencies\n\nThe tool result component relies on shadcn-ui's Card component. We will install it as a dependency.\n\nnpx shadcn@latest add card\n\nYou will be prompted to setup a components.json file, after this step, a card UI component will be installed in your project.\n\nAdd PriceSnapshot\n\nWe create a new file under /components/tools/price-snapshot/price-snapshot.tsx to define the new tool result UI.\n\n@/components/tools/price-snapshot/price-snapshot.tsx\n\"use client\";\n \nimport { ArrowDownIcon, ArrowUpIcon } from \"lucide-react\";\n \nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\n \ntype PriceSnapshotToolArgs = {\n  ticker: string;\n};\n \ntype PriceSnapshotToolResult = {\n  price: number;\n  day_change: number;\n  day_change_percent: number;\n  time: string;\n};\n \nexport function PriceSnapshot({\n  ticker,\n  price,\n  day_change,\n  day_change_percent,\n  time,\n}: PriceSnapshotToolArgs & PriceSnapshotToolResult) {\n  const isPositiveChange = day_change >= 0;\n  const changeColor = isPositiveChange ? \"text-green-600\" : \"text-red-600\";\n  const ArrowIcon = isPositiveChange ? ArrowUpIcon : ArrowDownIcon;\n \n  return (\n    <Card className=\"mx-auto w-full max-w-md\">\n      <CardHeader>\n        <CardTitle className=\"text-2xl font-bold\">{ticker}</CardTitle>\n      </CardHeader>\n      <CardContent>\n        <div className=\"grid grid-cols-2 gap-4\">\n          <div className=\"col-span-2\">\n            <p className=\"text-3xl font-semibold\">${price?.toFixed(2)}</p>\n          </div>\n          <div>\n            <p className=\"text-muted-foreground text-sm\">Day Change</p>\n            <p\n              className={`flex items-center text-lg font-medium ${changeColor}`}\n            >\n              <ArrowIcon className=\"mr-1 h-4 w-4\" />$\n              {Math.abs(day_change)?.toFixed(2)} (\n              {Math.abs(day_change_percent)?.toFixed(2)}%)\n            </p>\n          </div>\n          <div>\n            <p className=\"text-muted-foreground text-sm\">Last Updated</p>\n            <p className=\"text-lg font-medium\">\n              {new Date(time).toLocaleTimeString()}\n            </p>\n          </div>\n        </div>\n      </CardContent>\n    </Card>\n  );\n}\nUpdate PriceSnapshotTool\n\nWe will import the new <PriceSnapshot /> component and use it in the render function whenever a tool result is available.\n\n@/components/tools/price-snapshot/PriceSnapshotTool.tsx\n\"use client\";\n \nimport { PriceSnapshot } from \"./price-snapshot\";\nimport { makeAssistantToolUI } from \"@assistant-ui/react\";\n \ntype PriceSnapshotToolArgs = {\n  ticker: string;\n};\n \ntype PriceSnapshotToolResult = {\n  snapshot: {\n    price: number;\n    day_change: number;\n    day_change_percent: number;\n    time: string;\n  };\n};\n \nexport const PriceSnapshotTool = makeAssistantToolUI<\n  PriceSnapshotToolArgs,\n  string\n>({\n  toolName: \"price_snapshot\",\n  render: function PriceSnapshotUI({ args, result }) {\n    let resultObj: PriceSnapshotToolResult | { error: string };\n    try {\n      resultObj = result ? JSON.parse(result) : {};\n    } catch (e) {\n      resultObj = { error: result! };\n    }\n \n    return (\n      <div className=\"mb-4 flex flex-col items-center gap-2\">\n        <pre className=\"whitespace-pre-wrap break-all text-center\">\n          price_snapshot({JSON.stringify(args)})\n        </pre>\n        {\"snapshot\" in resultObj && (\n          <PriceSnapshot ticker={args.ticker} {...resultObj.snapshot} />\n        )}\n        {\"error\" in resultObj && (\n          <p className=\"text-red-500\">{resultObj.error}</p>\n        )}\n      </div>\n    );\n  },\n});\nTry it out!\n\nAsk the assistant for the current stock price of Tesla. You should see the tool result appear:\n\nFallback tool UI\n\nInstead of defining a custom tool UI for every tool, we can also define a fallback UI for all tools that are not explicitly defined.\n\nThis requires shadcn-ui's Button component. We will install it as a dependency.\n\nnpx shadcn@latest add button\n\nThen create a new file under /components/tools/ToolFallback.tsx to define the fallback UI.\n\n@/components/tools/ToolFallback.tsx\nimport { ToolCallContentPartComponent } from \"@assistant-ui/react\";\nimport { CheckIcon, ChevronDownIcon, ChevronUpIcon } from \"lucide-react\";\nimport { useState } from \"react\";\nimport { Button } from \"../ui/button\";\n \nexport const ToolFallback: ToolCallContentPartComponent = ({\n  toolName,\n  argsText,\n  result,\n}) => {\n  const [isCollapsed, setIsCollapsed] = useState(true);\n  return (\n    <div className=\"mb-4 flex w-full flex-col gap-3 rounded-lg border py-3\">\n      <div className=\"flex items-center gap-2 px-4\">\n        <CheckIcon className=\"size-4\" />\n        <p className=\"\">\n          Used tool: <b>{toolName}</b>\n        </p>\n        <div className=\"flex-grow\" />\n        <Button onClick={() => setIsCollapsed(!isCollapsed)}>\n          {isCollapsed ? <ChevronUpIcon /> : <ChevronDownIcon />}\n        </Button>\n      </div>\n      {!isCollapsed && (\n        <div className=\"flex flex-col gap-2 border-t pt-2\">\n          <div className=\"px-4\">\n            <pre className=\"whitespace-pre-wrap\">{argsText}</pre>\n          </div>\n          {result !== undefined && (\n            <div className=\"border-t border-dashed px-4 pt-2\">\n              <p className=\"font-semibold\">Result:</p>\n              <pre className=\"whitespace-pre-wrap\">\n                {typeof result === \"string\"\n                  ? result\n                  : JSON.stringify(result, null, 2)}\n              </pre>\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n};\nBind fallback UI\n@/app/page.tsx\nimport { ToolFallback } from \"@/components/tools/ToolFallback\";\n \nexport default function Home() {\n  return (\n    <div className=\"flex h-full flex-col\">\n      <Thread\n        ...\n        assistantMessage={{ components: { Text: MarkdownText, ToolFallback } }}\n      />\n    </div>\n  );\n}\n\nPrevious\n\nPart 1: Setup frontend\n\nNext\n\nPart 3: Approval UI"
  },
  {
    "title": "Architecture | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/concepts/architecture",
    "html": "Concepts\nArchitecture\nArchitecture\n\nassistant-ui consists of two parts, Runtime and UI Components.\n\nThe Runtime and UI Components each require independent setup and both must be set up.\n\nPrevious\n\nTool UIs\n\nNext\n\nRuntime Layer"
  },
  {
    "title": "Part 1: Setup frontend | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/runtimes/langgraph/tutorial/part-1",
    "html": "LangGraph Cloud\nTutorial: Stockbroker\nPart 1: Setup frontend\nCreate a new project\n\nRun the following command to create a new Next.js project with the LangGraph assistant-ui template:\n\nnpx create-assistant-ui@latest -t langgraph my-app\ncd my-app\n\nYou should see the following files in your project:\n\nmy-app\napp\napi\n[...path]\nroute.ts\nglobals.css\nlayout.tsx\nMyRuntimeProvider.tsx\npage.tsx\nlib\nnext.config.mjs\npackage.json\npostcss.config.mjs\ntailwind.config.ts\ntsconfig.json\nSetup environment variables\n\nCreate a .env.local file in your project with the following variables:\n\n@/.env.local\nLANGGRAPH_API_URL=https://assistant-ui-stockbroker.vercel.app/api\nNEXT_PUBLIC_LANGGRAPH_ASSISTANT_ID=stockbroker\n\nThis connects the frontend to a LangGraph Cloud endpoint running under\nhttps://assistant-ui-stockbroker.vercel.app/api.\nThis endpoint is running the LangGraph agent defined in this repository.\n\nStart the server\n\nYou can start the server by running the following command:\n\nnpm run dev\n\nThe server will start and you can view the frontend by opening a browser tab to http://localhost:3000.\n\nYou should be able to chat with the assistant and see LLM responses streaming in real-time.\n\nExplore features\nStreaming\n\nStreaming message support is enabled by default. Tokens are streamed in real-time as the LLM generates them.\n\nMarkdown support\n\nRich text rendering using Markdown is enabled by default. You can view /app/page.tsx to see how this is implemented. The makeMarkdownText function accepts a configuration object to customize the markdown parser.\n\n@/app/page.tsx\n\"use client\";\n \nimport { Thread } from \"@assistant-ui/react\";\nimport { makeMarkdownText } from \"@assistant-ui/react-markdown\";\n \nconst MarkdownText = makeMarkdownText();\n \nexport default function Home() {\n  return (\n    <main className=\"h-full\">\n      <Thread assistantMessage={{ components: { Text: MarkdownText } }} />\n    </main>\n  );\n}\nAdd conversation starter messages\n\nIn order to help users understand what the assistant can do, we can add some conversation starter messages.\n\n@/app/page.tsx\nexport default function Home() {\n  return (\n    <div className=\"flex h-full flex-col\">\n      <Thread\n        welcome={{\n          suggestions: [\n            {\n              prompt: \"How much revenue did Apple make last year?\",\n            },\n            {\n              prompt: \"Is McDonald's profitable?\",\n            },\n            {\n              prompt: \"What's the current stock price of Tesla?\",\n            },\n          ],\n        }}\n        assistantMessage={{ components: { Text: MarkdownText } }}\n      />\n    </div>\n  );\n}\n\nPrevious\n\nIntroduction\n\nNext\n\nPart 2: Generative UI"
  },
  {
    "title": "useAssistant Runtime | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/runtimes/vercel-ai-sdk/use-assistant",
    "html": "Vercel AI SDK\nuseAssistant Runtime\nOverview\n\nIntegration with the Vercel AI SDK UI's useAssistant hook.\nThis allows interaction with the OpenAI Assistants API.\n\nGetting Started\nCreate a Next.JS project\nnpx create-next-app@latest my-app\ncd my-app\nInstall Vercel AI SDK and @assistant-ui/react-ai-sdk\nnpm install @assistant-ui/react @assistant-ui/react-ai-sdk ai openai\nSetup a backend route under /api/assistant\n\n/app/api/assistant/route.ts\n\nimport { AssistantResponse } from \"ai\";\nimport OpenAI from \"openai\";\nimport type { Run } from 'openai/resources/beta/threads/runs/runs';\n \nconst openai = new OpenAI();\n \n// Allow streaming responses up to 30 seconds\nexport const maxDuration = 30;\n \nexport async function POST(req: Request) {\n  // Parse the request body\n  const input: {\n    threadId: string | null;\n    message: string;\n  } = await req.json();\n \n  // Create a thread if needed\n  const threadId = input.threadId ?? (await openai.beta.threads.create({})).id;\n \n  // Add a message to the thread\n  const createdMessage = await openai.beta.threads.messages.create(threadId, {\n    role: \"user\",\n    content: input.message,\n  });\n \n  return AssistantResponse(\n    { threadId, messageId: createdMessage.id },\n    async ({ forwardStream, sendDataMessage }) => {\n      // Run the assistant on the thread\n      const runStream = openai.beta.threads.runs.stream(threadId, {\n        assistant_id:\n          process.env.ASSISTANT_ID ??\n          (() => {\n            throw new Error(\"ASSISTANT_ID is not set\");\n          })(),\n      });\n \n      // forward run status would stream message deltas\n      let runResult: Run = await forwardStream(runStream);\n \n      // status can be: queued, in_progress, requires_action, cancelling, cancelled, failed, completed, or expired\n      while (\n        runResult?.status === \"requires_action\" &&\n        runResult.required_action?.type === \"submit_tool_outputs\"\n      ) {\n        const tool_outputs =\n          runResult.required_action.submit_tool_outputs.tool_calls.map(\n            (toolCall: any) => {\n              const parameters = JSON.parse(toolCall.function.arguments);\n \n              switch (toolCall.function.name) {\n                // configure your tool calls here\n \n                default:\n                  throw new Error(\n                    `Unknown tool call function: ${toolCall.function.name}`,\n                  );\n              }\n            },\n          );\n \n        runResult = await forwardStream(\n          openai.beta.threads.runs.submitToolOutputsStream(\n            threadId,\n            runResult.id,\n            { tool_outputs },\n          ),\n        );\n      }\n    },\n  );\n}\nDefine a MyRuntimeProvider component\n\n@/app/MyRuntimeProvider.tsx\n\n\"use client\";\n \nimport { useAssistant } from \"ai/react\";\nimport { AssistantRuntimeProvider } from \"@assistant-ui/react\";\nimport { useVercelUseAssistantRuntime } from \"@assistant-ui/react-ai-sdk\";\n \nexport function MyRuntimeProvider({\n  children,\n}: Readonly<{\n  children: React.ReactNode;\n}>) {\n  const assistant = useAssistant({\n    api: \"/api/assistant\",\n  });\n \n  const runtime = useVercelUseAssistantRuntime(assistant);\n \n  return (\n    <AssistantRuntimeProvider runtime={runtime}>\n      {children}\n    </AssistantRuntimeProvider>\n  );\n}\nWrap your app in MyRuntimeProvider\n\n@/app/layout.tsx\n\nimport { MyRuntimeProvider } from '@/app/MyRuntimeProvider';\n \n...\n \nexport default function RootLayout({\n  children,\n}: Readonly<{\n  children: React.ReactNode;\n}>) {\n  return (\n    <MyRuntimeProvider>\n      <html lang=\"en\">\n        <body className={inter.className}>\n          {children}\n        </body>\n      </html>\n    </MyRuntimeProvider>\n  )\n}\n\nPrevious\n\nVercel AI SDK RSC Runtime\n\nNext\n\nuseChat Runtime"
  },
  {
    "title": "Introduction | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/runtimes/langgraph/tutorial/introduction",
    "html": "LangGraph Cloud\nTutorial: Stockbroker\nIntroduction\n\nIn this tutorial, we will build a stockbroker assistant using LangChain.js, LangGraph.js and assistant-ui.\n\nWe will go through the necessary steps to integrate assistant-ui with a LangGraph Cloud endpoint. Code snippets focus on the setup of the frontend, but we will highlight relevant sections of the backend code as well.\n\nThis agent leverages the following features:\n\nðŸš„ Streaming of messages from LangGraph state to assistant-ui\nðŸ’… Rich text rendering using Markdown\nðŸ› ï¸ Generative UI: Mapping tool calls to tool UIs\nðŸ” Approval UI: Confirming tool calls before execution (human-in-the-loop)\nPrerequisites\nNode.js 18.x or higher\nFinal Result\nDemo: https://assistant-ui-stockbroker.vercel.app/\nSource Code: https://github.com/Yonom/assistant-ui-stockbroker\nGet Started\n\nBegin Part 1 of the tutorial by setting up the frontend.\n\nPrevious\n\nIntroduction\n\nNext\n\nPart 1: Setup frontend"
  },
  {
    "title": "ContentPart | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/ui/primitives/ContentPart",
    "html": "Primitives\nContentPart\nAnatomy\nimport { ContentPartPrimitive } from \"@assistant-ui/react\";\n \nconst TextContentPart = () => {\n  return <ContentPartPrimitive.Text />;\n};\n \nconst ImageContentPart = () => {\n  return <ContentPartPrimitive.Image />;\n};\n \nconst UIContentPart = () => {\n  return <ContentPartPrimitive.Display />;\n};\nAPI Reference\nText\n\nRenders the text content of a text content part.\n\nThis primitive renders a <span> element.\n\nuseContentPartText\nimport { useContentPartText } from \"@assistant-ui/react\";\n \nconst Text = () => {\n  const text = useContentPartText();\n \n  return <span>{text}</span>;\n};\nImage\n\nRenders the image content of an image content part.\n\nThis primitive renders an <img> element.\n\nuseContentPartImage\nimport { useContentPartImage } from \"@assistant-ui/react\";\n \nconst Image = () => {\n  const image = useContentPartImage();\n \n  return <img src={image} alt=\"AI\" />;\n};\nDisplay\n\nRenders the display content of a UI content part. This feature is used by the Vercel RSC runtime.\n\nuseContentPartDisplay\nimport { useContentPartDisplay } from \"@assistant-ui/react\";\n \nconst Display = () => {\n  const display = useContentPartDisplay();\n \n  return <div>{display}</div>;\n};\nInProgress\n\nRenders children only if the content part is in progress. While a message is in progress, the very last content part is considered to be in progress.\n\nPrevious\n\nActionBar\n\nNext\n\nActionBar"
  },
  {
    "title": "ActionBar | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/ui/primitives/ActionBar",
    "html": "Primitives\nActionBar\n\nButtons to interact with the message.\n\nAnatomy\nimport { ActionBarPrimitive } from \"@assistant-ui/react\";\n \nconst UserMessageBar = () => (\n  <ActionBarPrimitive.Root>\n    <ActionBarPrimitive.Edit />\n    <ActionBarPrimitive.Copy />\n  </ActionBarPrimitive.Root>\n);\n \nconst AssistantMessageBar = () => (\n  <ActionBarPrimitive.Root>\n    <ActionBarPrimitive.Reload />\n    <ActionBarPrimitive.Copy />\n  </ActionBarPrimitive.Root>\n);\nAPI Reference\nContainer\n\nContaints all parts of the action bar.\n\nThis primitive renders a <div> element unless asChild is set.\n\nActionBarPrimitiveRootProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\nhideWhenRunning:\nboolean = false\n\nDo not render the ActionBar when the thread is in running state.\n\nautohide:\n\"always\" | \"not-last\" | \"never\" = \"never\"\n\nDo not render the ActionBar unless the mouse is hovering over the message.\n\n\"always\": always autohide.\n\"not-last\"; only autohide if the message is not the last one in the thread.\n\nautohideFloat:\n\"always\" | \"single-branch\" | \"never\" = \"never\"\n\nFloat the ActionBar during autohide.\n\n\"always\": always float during autohide.\n\"single-branch\": only float if the message is the only one in the thread.\n\nNote: this only sets `data-floating` on the ActionBar. You need to set the appropriate styles on the ActionBar to make it float.\n\nData attribute\tValues\n[data-floating]\t\n\nPresent when floating\n\nEdit\n\nEnables edit mode on user message.\n\nThis primitive renders a <button> element unless asChild is set.\n\nActionBarPrimitiveEditProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\nReload\n\nRegenerates the assistant message.\n\nThis primitive renders a <button> element unless asChild is set.\n\nActionBarPrimitiveReloadProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\nCopy\n\nCopies the message to the clipboard.\n\nThis primitive renders a <button> element unless asChild is set.\n\nActionBarPrimitiveCopyProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\ncopiedDuration:\nnumber = 3000\n\nThe duration in milliseconds to change the message status to 'copied'.\n\nData attribute\tValues\n[data-copied]\t\n\nPresent when the message was recently copied.\n\nCopied state\n\nShow a different icon for a few seconds after the message is copied.\n\n<ActionBarPrimitive.Copy>\n  <MessagePrimitive.If copied={false}>\n    <CopyIcon />\n  </MessagePrimitive.If>\n  <MessagePrimitive.If copied>\n    <CopySuccessIcon />\n  </MessagePrimitive.If>\n</ActionBarPrimitive.Copy>\n\nor using the data-copied attribute:\n\n<ActionBarPrimitive.Copy className=\"group\">\n  <CopyIcon className=\"group-data-[copied]:hidden\" />\n  <CheckIcon className=\"hidden group-data-[copied]:block\" />\n</ActionBarPrimitive.Copy>\nSpeak\n\nPlays the message text as speech.\n\nThis primitive renders a <button> element unless asChild is set.\n\nActionBarPrimitiveSpeakProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\nStopSpeaking\n\nStops the message text from being played as speech.\n\nThis primitive renders a <button> element unless asChild is set.\n\nActionBarPrimitiveStopSpeakingProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\nFeedback Positive\n\nShows a positive feedback submission button.\n\nThis primitive renders a <button> element unless asChild is set.\n\nActionBarPrimitiveFeedbackPositiveProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\nData attribute\tValues\n[data-submitted]\t\n\nPresent when positive feedback was submitted.\n\nFeedback Negative\n\nShows a negative feedback submission button.\n\nThis primitive renders a <button> element unless asChild is set.\n\nActionBarPrimitiveFeedbackNegativeProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\nData attribute\tValues\n[data-submitted]\t\n\nPresent when negative feedback was submitted.\n\nPrevious\n\nBranchPicker\n\nNext\n\nContentPart"
  },
  {
    "title": "BranchPicker | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/ui/primitives/BranchPicker",
    "html": "Primitives\nBranchPicker\n\nView and switch between branches.\n\nAnatomy\nimport { BranchPickerPrimitive } from \"@assistant-ui/react\";\n \nconst BranchPicker = () => (\n  <BranchPickerPrimitive.Root>\n    <BranchPickerPrimitive.Previous />\n    <BranchPickerPrimitive.Number /> / <BranchPickerPrimitive.Count />\n    <BranchPickerPrimitive.Next />\n  </BranchPickerPrimitive.Root>\n);\nAPI Reference\nRoot\n\nContaints all parts of the branch picker.\n\nThis primitive renders a <div> element unless asChild is set.\n\nBranchPickerPrimitiveRootProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\nhideWhenSingleBranch:\nboolean = false\n\nDo not render the BranchPicker when there is only one branch at the current message.\n\nNumber\n\nThe current branch number.\n\nThis primitive renders the raw number as a string.\n\nCount\n\nThe total number of branches.\n\nThis primitive renders the raw number as a string.\n\nPrevious\n\nNavigates to the previous branch.\n\nThis primitive renders a <button> element unless asChild is set.\n\nBranchPickerPrimitivePreviousProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\nNext\n\nNavigates to the next branch.\n\nThis primitive renders a <button> element unless asChild is set.\n\nBranchPickerPrimitiveNextProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\nPrevious\n\nMessage\n\nNext\n\nActionBar"
  },
  {
    "title": "Message | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/ui/primitives/Message",
    "html": "Primitives\nMessage\n\nA single message in a conversation. Messages may consist of multiple parts.\n\nAnatomy\nimport { MessagePrimitive } from \"@assistant-ui/react\";\n \nconst UserMessage = () => (\n  <MessagePrimitive.Root>\n    User: <MessagePrimitive.Content />\n    <BranchPicker />\n    <ActionBar />\n  </MessagePrimitive.Root>\n);\n \nconst AssistantMessage = () => (\n  <MessagePrimitive.Root>\n    Assistant: <MessagePrimitive.Content />\n    <BranchPicker />\n    <ActionBar />\n  </MessagePrimitive.Root>\n);\nAPI Reference\nRoot\n\nContaints all parts of the message.\n\nThis primitive renders a <div> element unless asChild is set.\n\nMessagePrimitiveRootProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\nContent\n\nThe content of the message. This renders a separate component for each content part of the message.\n\nMessagePrimitiveContentProps\ncomponents?:\nContentPartComponents\n\nThe components to render for each content part.\n\nContentPartComponents\nText?:\nTextContentPartComponent\n\nThe component to render for each text content part.\n\nImage?:\nImageContentPartComponent\n\nThe component to render for each image content part.\n\nAudio?:\nUnstable_AudioContentPartComponent\n\nThe component to render for each audio content part.\n\nUI?:\nUIContentPartComponent\n\nThe component to render for each UI content part.\n\ntools?:\nobject\n\nThe component to render for each tool call content part.\n\nby_name?:\nRecord<string, ToolCallContentPartComponent>\n\nThe components to render for each tool call content part.\n\nFallback?:\nToolCallContentPartComponent\n\nThe fallback component to render for tool call content parts.\n\nIf\n\nRenders children if a condition is met.\n\nUseMessageIfProps\nuser?:\nboolean | undefined\n\nRender children if the message is from the user.\n\nassistant?:\nboolean | undefined\n\nRender children if the message is from the assistant.\n\nhasBranches?:\nboolean | undefined\n\nRender children if the message has branches.\n\ncopied?:\nboolean | undefined\n\nRender children if the message is copied.\n\nlastOrHover?:\nboolean | undefined\n\nRender children if the message is the last or hovered over.\n\n<Message.If user>\n  {/* rendered if message is from the user */}\n</Message.If>\n<Message.If assistant>\n  {/* rendered if message is from the assistant */}\n</Message.If>\n\nPrevious\n\nComposer\n\nNext\n\nBranchPicker"
  },
  {
    "title": "Composer | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/ui/primitives/Composer",
    "html": "Primitives\nComposer\n\nThe user interface to add new messages or edit existing ones.\n\nDual Use! A Composer placed directly inside a Thread will compose new messages. A Composer placed inside a Message will edit that message.\n\nAnatomy\nimport { ComposerPrimitive } from \"@assistant-ui/react\";\n \n// creating a new message\nconst Composer = () => (\n  <ComposerPrimitive.Root>\n    <ComposerPrimitive.Attachments />\n    <ComposerPrimitive.AddAttachment />\n    <ComposerPrimitive.Input />\n    <ComposerPrimitive.Send />\n  </ComposerPrimitive.Root>\n);\n \n// editing an existing message\nconst EditComposer = () => (\n  <ComposerPrimitive.Root>\n    <ComposerPrimitive.Input />\n    <ComposerPrimitive.Send />\n    <ComposerPrimitive.Cancel />\n  </ComposerPrimitive.Root>\n);\nAPI Reference\nRoot\n\nContaints all parts of the composer.\n\nThis primitive renders a <form> element unless asChild is set.\n\nComposerRootProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\nInput\n\nThe text input field for the user to type a new message.\n\nThis primitive renders a <textarea> element unless asChild is set.\n\nComposerPrimitiveInputProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\nKeyboard Shortcuts\nKey\tDescription\n\nEnter\n\tSends the message.\n\nEscape\n\tSends a cancel action.\nSend\n\nThe button to send the message.\n\nThis primitive renders a <button> element unless asChild is set.\n\nComposerPrimitiveSendProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\nCancel\n\nSends a cancel action.\n\nIn edit composers, this action exits the edit mode.\nIn thread composers, this action stops the current run.\n\nThis primitive renders a <button> element unless asChild is set.\n\nComposerPrimitiveCancelProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\nAttachments\n\nRenders attachments. This primitive renders a separate component for each attachment.\n\nComposerPrimitiveAttachmentsProps\ncomponents?:\nComposerAttachmentsComponents\n\nThe component to render for each attachment.\n\nComposerPrimitiveAttachmentsProps['components']\nImage?:\nComponentType\n\nThe component to render for each image attachment.\n\nDocument?:\nComponentType\n\nThe component to render for each document attachment.\n\nFile?:\nComponentType\n\nThe component to render for each file attachment.\n\nFallback?:\nComponentType\n\nThe component to render for each attachment type.\n\nAddAttachment\n\nRenders a button to add an attachment.\n\nThis primitive renders a <button> element unless asChild is set.\n\nComposerPrimitiveAddAttachmentProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\nIf\n\nRenders children if a condition is met.\n\nUseComposerIfProps\nediting?:\nboolean | undefined\n\nRender children if the message is being edited.\n\n<Composer.If editing>{/* rendered if message is being edited */}</Composer.If>\n\nPrevious\n\nThread\n\nNext\n\nMessage"
  },
  {
    "title": "Thread | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/ui/primitives/Thread",
    "html": "Primitives\nThread\n\nA conversation between a user and an assistant.\n\nAnatomy\nimport { ThreadPrimitive } from \"@assistant-ui/react\";\n \nconst Thread = () => (\n  <ThreadPrimitive.Root>\n    <ThreadPrimitive.Viewport>\n      <ThreadPrimitive.Empty>...</ThreadPrimitive.Empty>\n      <ThreadPrimitive.Messages components={...} />\n    </ThreadPrimitive.Viewport>\n    <Composer />\n  </ThreadPrimitive.Root>\n);\nAPI Reference\nRoot\n\nContaints all parts of the thread.\n\nThis primitive renders a <div> element unless asChild is set.\n\nThreadPrimitiveRootProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\nViewport\n\nThe scrollable area containing all messages. Anchors scroll to the bottom as new messages are added.\n\nThis primitive renders a <div> element unless asChild is set.\n\nThreadPrimitiveViewportProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\nautoScroll:\nboolean = true\n\nWhether to automatically scroll to the bottom of the viewport when new messages are added while the viewport is was previously scrolled to the bottom.\n\nMessages\n\nRenders all messages. This primitive renders a separate component for each message.\n\nThreadPrimitiveMessagesProps\ncomponents?:\nMessageComponents\n\nThe component to render for each message.\n\nMessageComponents\nMessage?:\nComponentType\n\nThe component to render for each message.\n\nUserMessage?:\nComponentType\n\nThe component to render for user messages.\n\nEditComposer?:\nComponentType\n\nThe component to render for user messages that are being edited.\n\nAssistantMessage?:\nComponentType\n\nThe component to render for assistant messages.\n\nEmpty\n\nRenders children only when there are no messages.\n\nScrollToBottom\n\nA button to scroll the viewport to the bottom. Disabled when the viewport is already at bottom.\n\nThis primitive renders a <button> element unless asChild is set.\n\nThreadPrimitiveScrollToBottomProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\nThreadPrimitive.Suggestion\n\nShows a suggestion to the user. When the user clicks on the suggestion, the composer's value is set to the suggestion's prompt.\n\nThis primitive renders a <button> element unless asChild is set.\n\nimport { ThreadPrimitive } from \"@assistant-ui/react\";\n \nconst Suggestion = () => {\n  return (\n    <ThreadPrimitive.Suggestion\n      prompt=\"I need help with product search\"\n      method=\"replace\"\n      autoSend\n    />\n  );\n};\n \n<ParametersTable\n  type=\"ThreadPrimitiveSuggestionProps\"\n  parameters={[\n    {\n      name: \"prompt\",\n      type: \"string\",\n      description: \"The suggestion's prompt.\",\n    },\n    {\n      name: \"method\",\n      type: \"'replace'\",\n      description:\n        \"How does the suggestion interact with the composer's existing value.\",\n    },\n    {\n      name: \"autoSend\",\n      type: \"boolean\",\n      description:\n        \"Whether to automatically send the suggestion when the user clicks on it.\",\n      default: \"false\",\n    },\n  ]}\n/>;\nIf\n\nRenders children if a condition is met.\n\nThreadPrimitiveIfProps\nempty?:\nboolean | undefined\n\nRender children if the thread is empty.\n\nrunning?:\nboolean | undefined\n\nRender children if the thread is running.\n\n<Thread.If empty>\n  {/* equivalent to <Thread.Empty> */}\n</Thread.If>\n<Thread.If empty={false}>\n  {/* rendered if thread is not empty */}\n</Thread.If>\n\nPrevious\n\nAssistantModal\n\nNext\n\nComposer"
  },
  {
    "title": "AssistantModal | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/ui/primitives/AssistantModal",
    "html": "Primitives\nAssistantModal\n\nA modal chat UI usually displayed in the bottom right corner of the screen.\n\nAnatomy\nimport { AssistantModalPrimitive } from \"@assistant-ui/react\";\n \nconst Thread = () => (\n  <AssistantModalPrimitive.Root>\n    <AssistantModalPrimitive.Trigger>\n      <FloatingAssistantButton />\n    </AssistantModalPrimitive.Trigger>\n    <AssistantModalPrimitive.Content>\n      <Thread />\n    </AssistantModalPrimitive.Content>\n  </ThreadPrimitive.Root>\n);\nAPI Reference\nRoot\n\nContains all parts of the assistant modal.\n\nAssistantModalPrimitiveRootProps\ndefaultOpen:\nboolean = false\n\nThe open state of the assistant modal when it is initially rendered. Use when you do not need to control its open state.\n\nopen?:\nboolean\n\nNot recommended. The controlled open state of the assistant modal. Must be used in conjunction with onOpenChange.\n\nonOpenChange?:\n(open: boolean) => void\n\nEvent handler called when the open state of the assistant modal changes.\n\nmodal:\nboolean = false\n\nThe modality of the assistant modal. When set to true, interaction with outside elements will be disabled and only modal content will be visible to screen readers.\n\nTrigger\n\nA button that toggles the open state of the assistant modal. AssistantModalPrimitive.Content will position itself against this button.\n\nThis primitive renders a <button> element unless asChild is set.\n\nAssistantModalPrimitiveTriggerProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\nData attribute\tValues\n[data-state]\t\n\n\"open\" | \"closed\"\n\nAnchor\n\nThe anchor element that the assistant modal is attached to. Defaults to the Trigger element.\n\nThis primitive renders a <div> element unless asChild is set.\n\nContent\n\nThe component that pops out when the assistant modal is open.\n\nThis primitive renders a <div> element unless asChild is set.\n\nAssistantModalPrimitiveContentProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\nside:\n'top' | 'right' | 'bottom' | 'left' = 'top'\n\nThe side of the assistant modal to position against.\n\nalign:\n'start' | 'center' | 'end' = 'end'\n\nThe alignment of the assistant modal to position against.\n\ndissmissOnInteractOutside:\nboolean = false\n\nDismiss the assistant modal when the user interacts outside of it.\n\nRefer to radix-ui's Documentation for Popover.Content for more details.\n\nPrevious\n\nComposition\n\nNext\n\nThread"
  },
  {
    "title": "Decomposition | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/ui/styled/Decomposition",
    "html": "Styled Components\nDecomposition\nOverview\n\nThe Styled Components can be decomposed into smaller components. At each level, you can swap out a specific component with your own custom component.\n\nThread\n\nRenders an entire conversation thread.\n\nimport {\n  Thread,\n  ThreadWelcome,\n  Composer,\n  type ThreadConfig,\n} from \"@assistant-ui/react\";\n \nconst MyThread: FC<ThreadConfig> = (config) => {\n  return (\n    <Thread.Root config={config}>\n      <Thread.Viewport>\n        <ThreadWelcome />\n        <Thread.Messages />\n        <Thread.FollowupSuggestions />\n        <Thread.ViewportFooter>\n          <Thread.ScrollToBottom />\n          <Composer />\n        </Thread.ViewportFooter>\n      </Thread.Viewport>\n    </Thread.Root>\n  );\n};\n\nUsage:\n\n<MyThread />\nThread.Root\n\nContains all parts of the thread. Accepts a config prop which is used by many other styled components.\n\nThread.Viewport\n\nThe scrollable area containing all messages. Anchors scroll to the bottom as new messages are added.\n\nThread.Messages\n\nRenders all messages. This renders a separate component for each message (passed to the components prop).\n\nThread.ViewportFooter\n\nRenders the footer of the thread viewport. This is the sticky footer that does not scroll with the messages.\n\nThread.ScrollToBottom\n\nA button to scroll the viewport to the bottom. Hidden when the viewport is already at bottom.\n\nThreadWelcome\n\nRenders the welcome message when no messages are present.\n\nimport { ThreadWelcome } from \"@assistant-ui/react\";\n \nconst MyThreadWelcome: FC = () => {\n  return (\n    <ThreadWelcome.Root>\n      <ThreadWelcome.Center>\n        <ThreadWelcome.Avatar />\n        <ThreadWelcome.Message />\n      </ThreadWelcome.Center>\n      <ThreadWelcome.Suggestions />\n    </ThreadWelcome.Root>\n  );\n};\n\nUsage:\n\nDecompose Thread into MyThread and use MyThreadWelcome instead of ThreadWelcome.\n\nconst MyThread: FC<ThreadConfig> = (config) => {\n  ...\n  <MyThreadWelcome />\n  ...\n};\nThreadWelcome.Root\n\nContains all parts of the welcome message.\n\nThreadWelcome.Center\n\nThe centered content of the welcome message.\n\nThreadWelcome.Avatar\n\nThe avatar of the assistant.\n\nThreadWelcome.Message\n\nThe welcome message.\n\nThreadWelcome.Suggestions\n\nConversation starter suggestions.\n\nimport { ThreadWelcome } from \"@assistant-ui/react\";\n \nconst MyThreadWelcomeSuggestions: FC = () => {\n  return (\n    <div className=\"aui-thread-welcome-suggestion-container\">\n      <ThreadWelcome.Suggestion prompt=\"Write me a poem about the weather\" />\n      <ThreadWelcome.Suggestion prompt=\"What is assistant-ui?\" />\n    </div>\n  );\n};\nThreadWelcome.Suggestion\n\nA conversation starter suggestion.\n\nComposer\n\nRenders the composer.\n\nimport { Composer } from \"@assistant-ui/react\";\n \nconst MyComposer: FC = () => {\n  return (\n    <Composer.Root>\n      <Composer.Attachments />\n      <Composer.AddAttachment />\n      <Composer.Input autoFocus />\n      <Composer.Action />\n    </Composer.Root>\n  );\n};\n\nUsage:\n\nDecompose Thread into MyThread and use MyComposer instead of Composer.\n\nconst MyThread: FC<ThreadConfig> = (config) => {\n  ...\n  <MyComposer />\n  ...\n};\nComposer.Root\n\nContains all parts of the composer.\n\nComposer.Input\n\nThe text input field for the user to type a new message.\n\nComposer.Action\n\nThe button to send or cancel the message.\n\nimport { Composer, ThreadPrimitive } from \"@assistant-ui/react\";\n \nconst MyComposerAction: FC = () => {\n  return (\n    <>\n      <ThreadPrimitive.If running={false}>\n        <ComposerSend />\n      </ThreadPrimitive.If>\n      <ThreadPrimitive.If running>\n        <ComposerCancel />\n      </ThreadPrimitive.If>\n    </>\n  );\n};\nComposer.Send\n\nThe button to send the message.\n\nComposer.Cancel\n\nSends a cancel action.\n\nComposer.Attachments\n\nRenders attachments.\n\nComposer.AddAttachment\n\nRenders an add attachment button.\n\nAttachmentUI\n\nAttachmentUI is still experimental.\n\nRenders an attachment.\n\nimport { AttachmentUI } from \"@assistant-ui/react\";\n \nconst MyAttachmentUI: FC = () => {\n  return (\n    <AttachmentUI.Root>\n      attachment\n      <AttachmentUI.Remove />\n    </AttachmentUI.Root>\n  );\n};\nAttachmentUI.Root\n\nContains all parts of the composer attachment.\n\nAttachmentUI.Remove\n\nRenders a remove attachment button.\n\nAssistantMessage\n\nRenders an assistant message.\n\nimport { AssistantMessage } from \"@assistant-ui/react\";\n \nconst MyAssistantMessage: FC = () => {\n  return (\n    <AssistantMessage.Root>\n      <AssistantMessage.Avatar />\n      <AssistantMessage.Content />\n      <BranchPicker />\n      <AssistantActionBar />\n    </AssistantMessage.Root>\n  );\n};\n\nUsage:\n\nDecompose Thread into MyThread and pass MyAssistantMessage to Thread.MEssages\n\nconst MyThread: FC<ThreadConfig> = (config) => {\n  ...\n  <Thread.Messages components={{ AssistantMessage: MyAssistantMessage }} />\n  ...\n};\nAssistantMessage.Root\n\nContains all parts of the assistant message.\n\nAssistantMessage.Avatar\n\nThe avatar of the assistant.\n\nAssistantMessage.Content\n\nThe content of the assistant message.\n\nAssistantActionBar\n\nRenders the action bar for the assistant message.\n\nimport { AssistantActionBar } from \"@assistant-ui/react\";\n \nconst MyAssistantActionBar: FC = () => {\n  return (\n    <AssistantActionBar.Root\n      hideWhenRunning\n      autohide=\"not-last\"\n      autohideFloat=\"single-branch\"\n    >\n      <AssistantActionBar.SpeechControl />\n      <AssistantActionBar.Copy />\n      <AssistantActionBar.Reload />\n      <AssistantActionBar.FeedbackPositive />\n      <AssistantActionBar.FeedbackNegative />\n    </AssistantActionBar.Root>\n  );\n};\n\nUsage:\n\nDecompose AssistantMessage into MyAssistantMessage and use MyAssistantActionBar instead of AssistantActionBar.\n\nconst MyAssistantMessage: FC = () => {\n  ...\n  <MyAssistantActionBar />\n  ...\n};\nAssistantActionBar.Root\n\nContains all parts of the assistant action bar.\n\nAssistantActionBar.Reload\n\nShows a reload button.\n\nAssistantActionBar.Copy\n\nShows a copy button.\n\nAssistantActionBar.SpeechControl\n\nShows a speech control button (either Speak or StopSpeaking).\n\nAssistantActionBar.Speak\n\nShows a speak button.\n\nAssistantActionBar.StopSpeaking\n\nShows a stop speaking button.\n\nAssistantActionBar.FeedbackPositive\n\nShows a positive feedback button.\n\nAssistantActionBar.FeedbackNegative\n\nShows a negative feedback button.\n\nBranchPicker\n\nRenders the branch picker.\n\nimport { BranchPicker } from \"@assistant-ui/react\";\n \nconst MyBranchPicker: FC = () => {\n  return (\n    <BranchPicker.Root hideWhenSingleBranch>\n      <BranchPicker.Previous />\n      <BranchPicker.State />\n      <BranchPicker.Next />\n    </BranchPicker.Root>\n  );\n};\n\nUsage:\n\nDecompose AssistantMessage and UserMessage and use MyBranchPicker instead of BranchPicker.\n\nconst MyAssistantMessage: FC = () => {\n  ...\n  <MyBranchPicker />\n  ...\n};\nconst MyUserMessage: FC = () => {\n  ...\n  <MyBranchPicker />\n  ...\n};\nBranchPicker.Root\n\nContains all parts of the branch picker.\n\nBranchPicker.Previous\n\nShows a previous button.\n\nBranchPicker.Next\n\nShows a next button.\n\nBranchPicker.State\n\nShows the current branch number and total number of branches.\n\nimport { BranchPicker } from \"@assistant-ui/react\";\n \nconst MyBranchPickerState: FC = () => {\n  return (\n    <span className=\"aui-branch-picker-state\">\n      <BranchPicker.Number /> / <BranchPicker.Count />\n    </span>\n  );\n};\nBranchPicker.Number\n\nThe current branch number.\n\nBranchPicker.Count\n\nThe total number of branches.\n\nUserMessage\n\nRenders a user message.\n\nimport { UserMessage } from \"@assistant-ui/react\";\n \nconst MyUserMessage: FC = () => {\n  return (\n    <UserMessage.Root>\n      <UserMessage.Attachments />\n      <UserMessage.Content />\n      <UserActionBar />\n      <BranchPicker />\n    </UserMessage.Root>\n  );\n};\n\nUsage:\n\nDecompose Thread into MyThread and pass MyUserMessage to Thread.Messages\n\nconst MyThread: FC<ThreadConfig> = (config) => {\n  ...\n  <Thread.Messages components={{ UserMessage: MyUserMessage }} />\n  ...\n};\nUserMessage.Root\n\nContains all parts of the user message.\n\nUserMessage.Content\n\nThe content of the user message.\n\nUserMessage.Attachments\n\nRenders attachments.\n\nUserActionBar\n\nRenders the action bar for the user message.\n\nimport { UserActionBar } from \"@assistant-ui/react\";\n \nconst MyUserActionBar: FC = () => {\n  return (\n    <UserActionBar.Root hideWhenRunning autohide=\"not-last\">\n      <UserActionBar.Edit />\n    </UserActionBar.Root>\n  );\n};\n\nUsage:\n\nDecompose UserMessage into MyUserMessage and use MyUserActionBar instead of UserActionBar.\n\nconst MyUserMessage: FC = () => {\n  ...\n  <MyUserActionBar />\n  ...\n};\nUserActionBar.Root\n\nContains all parts of the user action bar.\n\nUserActionBar.Edit\n\nShows an edit button.\n\nUserAttachment\n\nRenders an attachment.\n\nimport { UserAttachment } from \"@assistant-ui/react\";\n \nconst MyUserAttachment: FC = () => {\n  return <UserAttachment.Root>attachment</UserAttachment.Root>;\n};\nUserAttachment.Root\n\nContains all parts of the user attachment.\n\nEditComposer\n\nRenders a user message being edited.\n\nimport { EditComposer } from \"@assistant-ui/react\";\n \nconst MyEditComposer: FC = () => {\n  return (\n    <EditComposer.Root>\n      <EditComposer.Input />\n      <EditComposer.Footer>\n        <EditComposer.Cancel />\n        <EditComposer.Send />\n      </EditComposer.Footer>\n    </EditComposer.Root>\n  );\n};\n\nUsage:\n\nDecompose Thread into MyThread and pass MyEditComposer to Thread.Messages.\n\nconst MyThread: FC<ThreadConfig> = (config) => {\n  ...\n  <Thread.Messages components={{ EditComposer: MyEditComposer }} />\n  ...\n};\nEditComposer.Root\n\nContains all parts of the edit composer.\n\nEditComposer.Input\n\nThe text input field for the user to type a new message.\n\nEditComposer.Footer\n\nThe footer of the edit composer.\n\nEditComposer.Cancel\n\nSends a cancel action.\n\nEditComposer.Send\n\nSends the message.\n\nAssistantModal\n\nRenders the assistant modal.\n\nimport { AssistantModal, Thread, type ThreadConfig } from \"@assistant-ui/react\";\n \nconst MyAssistantModal: FC<ThreadConfig> = (config) => {\n  return (\n    <AssistantModal.Root config={config}>\n      <AssistantModal.Trigger />\n      <AssistantModal.Content>\n        <Thread />\n      </AssistantModal.Content>\n    </AssistantModal.Root>\n  );\n};\n\nUsage:\n\n<MyAssistantModal />\nThreadList\n\nRenders a thread list.\n\nimport { ThreadList, ThreadListItem } from \"@assistant-ui/react\";\n \nconst MyThreadList = () => {\n  return (\n    <ThreadList.Root>\n      <ThreadList.New />\n      <ThreadList.Items />\n    </ThreadList.Root>\n  );\n};\nThreadListItem\n\nRenders a thread list item.\n\nimport { ThreadListItem, ThreadListItemPrimitive } from \"@assistant-ui/react\";\n \nconst MyThreadListItem = () => {\n  return (\n    <ThreadListItem.Root>\n      <ThreadListItemTrigger>\n        <ThreadListItemTitle />\n      </ThreadListItemTrigger>\n      <ThreadListItem.Archive />\n    </ThreadListItem.Root>\n  );\n};\n\nPrevious\n\nMarkdown\n\nNext\n\nCustom Scrollbar"
  },
  {
    "title": "Composition | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/ui/primitives/composition",
    "html": "Primitives\nComposition\n\nassistant-ui primitives are composable. This means that all props are forwarded, classes are merged, and event handlers are chained.\n\nMost primitives come with a default HTML element (usually div or button). If you already have a custom component, you can use the asChild prop to replace it:\n\n// use the primitive's <button> element\n<Composer.Send>Send</Composer.Send>;\n \n// use your own <Button> component\n<Composer.Send asChild>\n  <Button>Send</Button>\n</Composer.Send>;\n\nLearn more on Radix's composition guide.\n\nPrevious\n\nCustom Scrollbar\n\nNext\n\nAssistantModal"
  },
  {
    "title": "Custom Scrollbar | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/ui/styled/Scrollbar",
    "html": "Styled Components\nCustom Scrollbar\n\nIf you want to show a custom scrollbar UI of the Thread.Viewport in place of the system default, you can integrate @radix-ui/react-scroll-area. An example implementation of this is shadcn-ui's Scroll Area.\n\nAdd shadcn Scroll Area\nnpx shadcn@latest add scroll-area\n@radix-ui/react-scroll-area v1.2.0 release candidate required\n\nThe v1.2.0-rc.x release candidate can be installed via\n\npnpm add @radix-ui/react-scroll-area@next\nAdditional Styles\n\nThe radix-ui Viewport component adds an intermediate <div data-radix-scroll-area-content> element. Add the following CSS to your globals.css:\n\n@/app/globals.css\n.aui-thread-viewport > [data-radix-scroll-area-content] {\n  @apply flex flex-col items-center self-stretch bg-inherit;\n}\nIntegration\nDecompose Thread into MyThread (see Decomposition)\nWrap Thread.Root with <ScrollAreaPrimitive.Root asChild>\nWrap Thread.Viewport with <ScrollAreaPrimitive.Viewport asChild>\nAdd shadcn's <ScrollBar /> to Thread.Root\n\nThe resulting MyThread component should look like this:\n\nimport {\n  Thread,\n  ThreadWelcome,\n  Composer,\n  type ThreadConfig,\n} from \"@assistant-ui/react\";\nimport * as ScrollAreaPrimitive from \"@radix-ui/react-scroll-area\";\nimport { ScrollBar } from \"@/components/ui/scroll-area\";\n \nconst MyThread: FC<ThreadConfig> = (config) => {\n  return (\n    <ScrollAreaPrimitive.Root asChild>\n      <Thread.Root config={config}>\n        <ScrollAreaPrimitive.Viewport asChild>\n          <Thread.Viewport>\n            <ThreadWelcome />\n            <Thread.Messages />\n            <Thread.ViewportFooter>\n              <Thread.ScrollToBottom />\n              <Composer />\n            </Thread.ViewportFooter>\n          </Thread.Viewport>\n        </ScrollAreaPrimitive.Viewport>\n        <ScrollBar />\n      </Thread.Root>\n    </ScrollAreaPrimitive.Root>\n  );\n};\n\nPrevious\n\nDecomposition\n\nNext\n\nThread"
  },
  {
    "title": "Markdown | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/ui/styled/Markdown",
    "html": "Styled Components\nMarkdown\n\nAllow the assistant to display rich text using markdown.\n\nEnabling markdown support\nInstall @assistant-ui/react-markdown\nnpm install @assistant-ui/react-markdown\nSetup styles\nTailwind\nTailwind + shadcn-ui\nNot using Tailwind\n/tailwind.config.ts\n{\n  plugins: [\n    require(\"tailwindcss-animate\"),\n    require(\"@assistant-ui/react/tailwindcss\"),\n    require(\"@assistant-ui/react-markdown/tailwindcss\"),\n  ],\n}\nDefine a MarkdownText component\n@/components/markdown-text.tsx\nimport { makeMarkdownText } from \"@assistant-ui/react-markdown\";\n \nexport const MarkdownText = makeMarkdownText();\nUse it with Thread\n\nPass the MarkdownText component to your Thread component.\n\nimport { MarkdownText } from \"@/components/markdown-text\";\n \nconst Home = () => {\n  return (\n    <Thread assistantMessage={{ components: { Text: MarkdownText } }}>\n  );\n};\n\nPrevious\n\nAssistantModal\n\nNext\n\nDecomposition"
  },
  {
    "title": "AssistantModal | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/ui/styled/AssistantModal",
    "html": "Styled Components\nAssistantModal\nOverview\n\nA chat bubble shown in the bottom right corner of the screen. Useful for support or Q&A use cases.\n\nGetting Started\nImport CSS styles\n\nAdd the following to your tailwind.config.ts:\n\nTailwind\nTailwind + shadcn-ui\nNot using Tailwind\n/tailwind.config.ts\n{\n  plugins: [\n    require(\"tailwindcss-animate\"), // make sure to \"npm install tailwindcss-animate\"\n    require(\"@assistant-ui/react/tailwindcss\")({\n      components: [\"assistant-modal\"],\n    })\n  ],\n}\nUse it in your app\n/app/page.tsx\nimport { Thread, useEdgeRuntime } from \"@assistant-ui/react\";\n \nconst MyApp = () => {\n  const runtime = useEdgeRuntime({\n    api: \"/api/chat\",\n  });\n \n  return (\n    <div>\n      <AssistantModal runtime={runtime} />\n    </div>\n  );\n};\n\nPrevious\n\nThread Width\n\nNext\n\nMarkdown"
  },
  {
    "title": "Thread Width | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/ui/styled/ThreadWidth",
    "html": "Styled Components\nThread Width\n\nYou can modify the max width of the thread via the CSS variable --aui-thread-max-width.\n\nWider Thread\n@/app/globals.css\n:root {\n  --aui-thread-max-width: 600px;\n}\nTake up the whole screen\n@/app/globals.css\n:root {\n  --aui-thread-max-width: infinity;\n}\n\nPrevious\n\nThread\n\nNext\n\nAssistantModal"
  },
  {
    "title": "<AssistantRuntimeProvider /> | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/reference/AssistantRuntimeProvider",
    "html": "Reference\n<AssistantRuntimeProvider />\n\nThe AssistantRuntimeProvider provides data and APIs used by assistant-ui components.\n\nAlmost all components in assistant-ui require an AssistantRuntimeProvider around them to function properly.\n\nYou must either wrap your app in an AssistantRuntimeProvider or pass a runtime to the <Thread /> component instead.\n\nimport { AssistantRuntimeProvider } from \"@assistant-ui/react\";\n \nconst MyApp = () => {\n  const runtime = useEdgeRuntime({ api: \"/api/chat\" });\n \n  return (\n    <AssistantRuntimeProvider runtime={runtime}>\n      {/* your app */}\n    </AssistantRuntimeProvider>\n  );\n};\nProperties\nAssistantRuntimeProvider\nruntime:\nAssistantRuntime\n\nThe runtime to provide to the rest of your app.\n\nchildren?:\nReact.ReactNode\n\nPrevious\n\n@assistant-ui/react-hook-form\n\nNext\n\n<TextContentPartProvider />"
  },
  {
    "title": "Runtime API | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/reference/context",
    "html": "Reference\nRuntime API\n\nThe runtime API allows you to interact with the runtime in a standardized way. This API is used internaly by the components. You can also use it to build your own UI components or functionality.\n\nAssistantRuntime\n\nThe AssistantRuntime is the root runtime.\n\nuseAssistantRuntime\nimport { useAssistantRuntime } from \"@assistant-ui/react\";\n \nconst runtime = useAssistantRuntime();\nAssistantRuntime\nthread:\nThreadRuntime\n\nThe currently selected main thread.\n\nthreadList:\nThreadListRuntime\n\nThe thread manager, to rename, archive and delete threads.\n\nswitchToNewThread:\n() => void\n\nSwitch to a new thread.\n\nswitchToThread:\n(threadId: string) => void\n\nSwitch to a thread.\n\nregisterModelConfigProvider:\n(provider: ModelConfigProvider) => Unsubscribe\n\nRegister a model config provider. Model config providers are configuration such as system message, temperature, etc. that are set in the frontend.\n\nTool UI Registry\n\nThe tool UI registry is used to display custom UI for tool calls, enabling generative UI.\n\nuseToolUIs\nimport { useToolUIs } from \"@assistant-ui/react\";\n \nconst toolUIs = useToolUIs();\nconst webSearchToolUI = useToolUIs((m) => m.getToolUI(\"web_search\"));\nAssistantToolUIsState\ngetToolUI:\n(toolName: string) => ToolCallContentPartComponent | null\n\nGet the tool UI configured for a given tool name.\n\nsetToolUI:\n(toolName: string, render: ToolCallContentPartComponent) => Unsubscribe\n\nRegisters a tool UI for a given tool name. Returns an unsubscribe function to remove the tool UI.\n\nThreadListRuntime\nthreadList\nimport { useAssistantRuntime } from \"@assistant-ui/react\";\n \nconst threadListRuntime = useAssistantRuntime().threadList;\nThreadListRuntime\ngetState:\n() => ThreadListState\n\nsubscribe:\n(callback: () => void) => Unsubscribe\n\nmainItem:\nThreadListItemRuntime\n\ngetItemById:\n(threadId: string) => ThreadListItemRuntime\n\ngetItemByIndex:\n(idx: number) => ThreadListItemRuntime\n\ngetArchivedItemByIndex:\n(idx: number) => ThreadListItemRuntime\n\nuseThreadList\nimport { useThreadList } from \"@assistant-ui/react\";\n \nconst threadList = useThreadList();\nconst threads = useThreadList((m) => m.threads);\nThreadListItemRuntime\nuseThreadListItemRuntime\nimport { useThreadListItemRuntime } from \"@assistant-ui/react\";\n \nconst threadListItemRuntime = useThreadListItemRuntime();\nThreadListItemRuntime\npath:\nThreadListItemRuntimePath\n\ngetState:\n() => ThreadListItemState\n\nswitchTo:\n() => Promise<void>\n\nrename:\n(newTitle: string) => Promise<void>\n\narchive:\n() => Promise<void>\n\nunarchive:\n() => Promise<void>\n\ndelete:\n() => Promise<void>\n\nsubscribe:\n(callback: () => void) => Unsubscribe\n\nunstable_on:\n(event: ThreadListItemEventType, callback: () => void) => Unsubscribe\n\nuseThreadListItem\nimport { useThreadListItem } from \"@assistant-ui/react\";\n \nconst threadListItem = useThreadListItem();\nconst title = useThreadListItem((m) => m.title);\nThreadListItemState\nisMain:\nboolean\n\nid:\nstring\n\nremoteId:\nstring | undefined\n\nexternalId:\nstring | undefined\n\nthreadId:\nstring\n\nstatus:\n\"archived\" | \"regular\" | \"new\" | \"deleted\"\n\ntitle?:\nstring | undefined\n\nThread Context\nuseThreadRuntime\nimport { useThreadRuntime } from \"@assistant-ui/react\";\n \nconst thread = useThreadRuntime();\nThreadRuntime\npath:\nThreadRuntimePath\n\nThe selector for the thread runtime.\n\ncomposer:\nThreadComposerRuntime\n\nThe thread composer runtime.\n\ngetState:\n() => ThreadState\n\nGets a snapshot of the thread state.\n\nappend:\n(message: CreateAppendMessage) => void\n\nAppend a new message to the thread.\n\nstartRun:\n{ (parentId: string | null): void; (config: StartRunConfig): void; }\n\nsubscribe:\n(callback: () => void) => Unsubscribe\n\ncancelRun:\n() => void\n\ngetModelConfig:\n() => ModelConfig\n\nexport:\n() => ExportedMessageRepository\n\nimport:\n(repository: ExportedMessageRepository) => void\n\ngetMesssageByIndex:\n(idx: number) => MessageRuntime\n\ngetMesssageById:\n(messageId: string) => MessageRuntime\n\nstopSpeaking:\n() => void\n\nunstable_on:\n(event: ThreadRuntimeEventType, callback: () => void) => Unsubscribe\n\nuseThread\nimport { useThread } from \"@assistant-ui/react\";\n \nconst thread = useThread();\nconst isRunning = useThread((m) => m.isRunning);\nThreadState\nthreadId:\nstring\n\nThe thread ID.\n\nmetadata:\nThreadListItemState\n\nThe thread metadata.\n\nisDisabled:\nboolean\n\nWhether the thread is disabled. Disabled threads cannot receive new messages.\n\nisRunning:\nboolean\n\nWhether the thread is running. A thread is considered running when there is an active stream connection to the backend.\n\ncapabilities:\nRuntimeCapabilities\n\nThe capabilities of the thread, such as whether the thread supports editing, branch switching, etc.\n\nmessages:\nreadonly ThreadMessage[]\n\nThe messages in the currently selected branch of the thread.\n\nsuggestions:\nreadonly ThreadSuggestion[]\n\nFollow up message suggestions to show the user.\n\nextras:\nunknown\n\nCustom extra information provided by the runtime.\n\nspeech:\nSpeechState | undefined\n\nuseThreadMessages\nimport { useThreadMessages } from \"@assistant-ui/react\";\n \nconst messages = useThreadMessages();\nconst firstMessage = useThreadMessages((m) => m[0]);\nThreadMessagesState\nmessages:\nreadonly ThreadMessage[]\n\nThe messages in the thread.\n\nuseThreadComposer\nimport { useThreadComposer } from \"@assistant-ui/react\";\n \nconst composer = useThreadComposer();\nconst text = useThreadComposer((m) => m.text);\nComposerState\ntext:\nstring\n\nThe current text of the composer.\n\nsetText:\n(text: string) => void\n\nA function to set the text of the composer.\n\nattachments:\nreadonly Attachment[]\n\nThe current attachments of the composer.\n\naddAttachment:\n(attachment: Attachment) => void\n\nA function to add an attachment to the composer.\n\nremoveAttachment:\n(attachmentId: string) => void\n\nA function to remove an attachment from the composer.\n\nreset:\n() => void\n\nA function to reset the composer.\n\ncanCancel:\ntrue\n\nWhether the composer can be canceled.\n\nisEditing:\ntrue\n\nWhether the composer is in edit mode.\n\nsend:\n() => void\n\nA function to send the message.\n\ncancel:\n() => void\n\nA function to cancel the run.\n\nfocus:\n() => void\n\nA function to focus the composer.\n\nonFocus:\n(listener: () => void) => Unsubscribe\n\nA function to subscribe to focus events.\n\nuseThreadViewport\nimport { useThreadViewport } from \"@assistant-ui/react\";\n \nconst threadViewport = useThreadViewport();\nconst isAtBottom = useThreadViewport((m) => m.isAtBottom);\nThreadViewportState\nisAtBottom:\nboolean\n\nWhether the thread is at the bottom.\n\nscrollToBottom:\n() => void\n\nA function to scroll to the bottom.\n\nonScrollToBottom:\n(callback: () => void) => Unsubscribe\n\nA function to subscribe to scroll to bottom events.\n\nMessage Context\nuseMessage\nimport { useMessage } from \"@assistant-ui/react\";\n \nconst { message } = useMessage();\nconst message = useMessage((m) => m.message);\nMessageState\nmessage:\nReadonly<ThreadMessage>\n\nThe current message.\n\nparentId:\nstring | null\n\nThe parent message id.\n\nbranches:\nreadonly string[]\n\nThe branches for the message.\n\nisLast:\nboolean\n\nWhether the message is the last in the thread.\n\nuseMessageUtils\nimport { useMessageUtils } from \"@assistant-ui/react\";\n \nconst messageUtils = useMessageUtils();\nconst isCopied = useMessageUtils((m) => m.isCopied);\nMessageUtilsState\nisCopied:\nboolean\n\nWhether the message is copied.\n\nsetIsCopied:\n(value: boolean) => void\n\nA function to set the is copied.\n\nisHovering:\nboolean\n\nWhether the message is being hovered.\n\nsetIsHovering:\n(value: boolean) => void\n\nA function to set the is hovering.\n\nisSpeaking:\nboolean\n\nWhether the message is currently being spoken.\n\nstopSpeaking:\n() => void\n\nA function to stop the message from being spoken.\n\naddUtterance:\n(utterance: SpeechSynthesisAdapter.Utterance) => void\n\nA function to add a speech utterance.\n\nuseEditComposer\nimport { useEditComposer } from \"@assistant-ui/react\";\n \nconst editComposer = useEditComposer();\nconst text = useEditComposer((m) => m.text);\nEditComposerState\ntext:\nstring\n\nThe current text of the composer.\n\nsetText:\n(text: string) => void\n\nA function to set the text of the composer.\n\nattachments:\nreadonly Attachment[]\n\nThe current attachments of the composer.\n\naddAttachment:\n(attachment: Attachment) => void\n\nA function to add an attachment to the composer.\n\nremoveAttachment:\n(attachmentId: string) => void\n\nA function to remove an attachment from the composer.\n\nreset:\n() => void\n\nA function to reset the composer.\n\ncanCancel:\nboolean\n\nWhether the composer can be canceled.\n\nisEditing:\nboolean\n\nWhether the composer is in edit mode.\n\nedit:\n() => void\n\nA function to enter edit mode.\n\nsend:\n() => void\n\nA function to send the message.\n\ncancel:\n() => void\n\nA function to exit the edit mode.\n\nContent Part Context\nuseContentPart\nimport { useContentPart } from \"@assistant-ui/react\";\n \nconst part = useContentPart();\nconst part = useContentPart.getState();\n \nconst status = useContentPart((m) => m.status);\nconst status = useContentPart.getState().status;\nContentPartState\npart:\nReadonly<ContentPartState>\n\nThe current content part.\n\nstatus:\nMessageStatus\n\nThe current content part status.\n\nMessageStatus\ntype:\n'running' | 'requires-action' | 'complete' | 'incomplete'\n\nThe status.\n\nfinish-reason?:\n'stop' | 'cancelled' | 'length' | 'content-filter' | 'tool-calls' | 'other' | 'unknown'\n\nThe finish reason if the status is 'incomplete'.\n\nerror?:\nunknown\n\nThe error object if the status is 'error'.\n\nComposer Context\n\nGrabs the nearest composer state (either the edit composer or the thread's new message composer).\n\nuseComposer\nimport { useComposer } from \"@assistant-ui/react\";\n \nconst composer = useComposer();\nconst text = useComposer((m) => m.text);\nAttachment Context\n\nGrabs the attachment state (either the composer or message attachment).\n\nuseAttachment\nimport { useAttachment } from \"@assistant-ui/react\";\n \nconst { attachment } = useAttachment();\nconst attachment = useAttachment((m) => m.attachment);\nuseComposerAttachment (Composer)\nimport { useComposerAttachment } from \"@assistant-ui/react\";\n \nconst { attachment } = useComposerAttachment();\nconst attachment = useComposerAttachment((m) => m.attachment);\nComposerAttachmentState\nattachment:\nComposerAttachment\n\nThe current composer attachment.\n\nuseMessageAttachment (Message)\nimport { useMessageAttachment } from \"@assistant-ui/react\";\n \nconst { attachment } = useMessageAttachment();\nconst attachment = useMessageAttachment((m) => m.attachment);\nMessageAttachmentState\nattachment:\nMessageAttachment\n\nThe current message attachment.\n\nPrevious\n\nContentPart\n\nNext\n\n@assistant-ui/react-ai-sdk"
  },
  {
    "title": "Tool UIs | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/guides/ToolUI",
    "html": "Guides\nTool UIs\n\nYou can show a custom UI when a tool is called to let the user know what is happening.\n\nTool UI Components\nimport { makeAssistantToolUI } from \"@assistant-ui/react\";\n \ntype WebSearchArgs = {\n  query: string;\n};\n \ntype WebSearchResult = {\n  title: string;\n  description: string;\n  url: string;\n};\n \nexport const WebSearchToolUI = makeAssistantToolUI<WebSearchArgs, WebSearchResult>({\n  toolName: \"web_search\",\n  render: ({ args, status }) => {\n    return <p>web_search({args.query})</p>;\n  },\n});\n\nYou can put this component anywhere in your app inside the <AssistantRuntimeProvider /> component.\n\nimport { WebSearchToolUI } from '@/tools/WebSearchToolUI';\n \nconst MyApp = () => {\n  ...\n  return (\n    <AssistantRuntimeProvider runtime={runtime}>\n      ...\n      <WebSearchToolUI />\n      ...\n    </AssistantRuntimeProvider>\n  );\n};\nTool UI Hooks\nimport { makeAssistantToolUI } from \"@assistant-ui/react\";\n \ntype WebSearchArgs = {\n  query: string;\n};\n \ntype WebSearchResult = {\n  title: string;\n  description: string;\n  url: string;\n};\n \nexport const useWebSearchToolUI = makeAssistantToolUI<WebSearchArgs, WebSearchResult>({\n  toolName: \"web_search\",\n  render: ({ args, status }) => {\n    return <p>web_search({args.query})</p>;\n  },\n});\n\nYou can use this hook anywhere in your app inside the <AssistantRuntimeProvider /> component.\n\nimport { useWebSearchToolUI } from '@/tools/useWebSearchToolUI';\n \nconst MyComponent = () => {\n  useWebSearchToolUI();\n \n  ...\n};\n \nconst MyApp = () => {\n  ...\n  return (\n    <AssistantRuntimeProvider runtime={runtime}>\n      ...\n      <MyComponent />\n      ...\n    </AssistantRuntimeProvider>\n  );\n};\nInline Tool UI Hooks\n\nIf you need access to component props, you can use the useAssistantToolUI hook. If you are passing a component inline, you should use the useInlineRender hook to prevent the component from being re-mounted on every render.\n\nimport { useAssistantToolUI, useInlineRender } from \"@assistant-ui/react\";\n \nconst MyComponent = ({ product_id }) => {\n  useAssistantToolUI({\n    toolName: \"current_product_info\",\n    render: useInlineRender(({ args, status }) => {\n      // you can access component props here\n      return <p>product_info({ product_id })</p>;\n    }),\n  });\n \n  ...\n};\n \nconst MyApp = () => {\n  ...\n  return (\n    <AssistantRuntimeProvider runtime={runtime}>\n      ...\n      <MyComponent product_id=\"123\" />\n      ...\n    </AssistantRuntimeProvider>\n  );\n};\nFunction Calling for User Input\n\nThe following example shows a date_picker tool that the AI can call to collect a date from the user.\n\nimport { makeAssistantToolUI } from \"@assistant-ui/react\";\nimport { DatePicker } from \"@/components/datepicker\";\n \nconst DatePickerToolUI = makeAssistantToolUI<{}, { date: string }>({\n  toolName: \"date_picker\",\n  render: ({ result, status, addResult }) => {\n    if (result) {\n      return <p>You picked {result.date}</p>;\n    }\n \n    const handleSubmit = (date: Date) => {\n      addResult({ date: date.toISOString() });\n    };\n \n    return <DatePicker onSubmit={handleSubmit} />;\n  },\n});\n\nPrevious\n\nSpeech\n\nNext\n\nArchitecture"
  },
  {
    "title": "Message Editing | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/guides/Editing",
    "html": "Guides\nMessage Editing\n\nGive the user the ability to edit their message.\n\nEnabling edit support\n\nYou can show an editor interface by using ComposerPrimitive.\n\nimport { ComposerPrimitive } from \"@assistant-ui/react\";\n...\n \nconst Thread = () => {\n  return (\n    <ThreadPrimitive.Root>\n      <ThreadPrimitive.Viewport>\n        ...\n        <ThreadPrimitive.Messages components={{\n          ...,\n          EditComposer, // <-- Show our new component during edit mode\n        }} />\n      </ThreadPrimitive.Viewport>\n      ...\n    </ThreadPrimitive.Root>\n  );\n};\n \nconst UserMessage = () => {\n  return (\n    <MessagePrimitive.Root>\n      ...\n      <ActionBarPrimitive.Root>\n        ...\n        <ActionBarPrimitive.Edit /> {/* <-- add a button to enable edit mode */}\n      </ActionBarPrimitive.Root>\n    </MessagePrimitive.Root>\n  );\n};\n \n// define a new component\nconst EditComposer = () => {\n  return (\n    // you can return a MessagePrimitive including a ComposerPrimitive, or only a ComposerPrimitive\n    <MessagePrimitive.Root>\n      ...\n      <ComposerPrimitive.Root>\n        <ComposerPrimitive.Input />\n        <ComposerPrimitive.Cancel />\n        <ComposerPrimitive.Send />\n      </ComposerPrimitive.Root>\n    </MessagePrimitive.Root>\n  );\n};\n\nPrevious\n\nMessage Branching\n\nNext\n\nSpeech"
  },
  {
    "title": "Speech | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/guides/Speech",
    "html": "Guides\nSpeech\nText-to-Speech\n\nassistant-ui supports text-to-speech via the SpeechSynthesisAdapter interface and the Edge runtime.\n\nSpeechSynthesisAdapter\n\nCurrently, the following speech synthesis adapters are supported:\n\nWebSpeechSynthesisAdapter: Uses the browser's Web Speech API API\n\nSupport for other speech synthesis adapters is planned for the future.\n\nPassing a SpeechSynthesisAdapter to the EdgeRuntime will enable text-to-speech support.\n\nUI\n\nBy default, a Read aloud button will be shown in the assistant message action bar.\n\nThis is implemented using AssistantActionBar.SpeechControl which is a wrapper around AssistantActionBar.Speak and AssistantActionBar.StopSpeaking. The underlying primitives are ActionBarPrimitive.Speak and ActionBarPrimitive.StopSpeaking.\n\nExample\n\nThe following example uses the WebSpeechSynthesisAdapter.\n\nimport { WebSpeechSynthesisAdapter } from \"@assistant-ui/react\";\n \nconst runtime = useEdgeRuntime({\n  api: \"/api/chat\",\n  adapters: {\n    speech: new WebSpeechSynthesisAdapter(),\n  },\n});\n\nPrevious\n\nMessage Editing\n\nNext\n\nTool UIs"
  },
  {
    "title": "Message Branching | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/guides/Branching",
    "html": "Guides\nMessage Branching\n\nSwitch between different conversation branches.\n\nA new branch is created when:\n\na user message is edited\nan assistant message is reloaded\n\nBranches are automatically tracked by assistant-ui by observing changes to the messages array.\n\nEnabling branch support\n\nYou can show a branch picker by using BranchPickerPrimitive.\n\nimport { BranchPickerPrimitive } from \"@assistant-ui/react\";\n \n \nconst Message = () => {\n  return (\n    <MessagePrimitive.Root>\n      ...\n      <BranchPicker /> {/* <-- show the branch picker */}\n      ...\n    </EditComposerPrimitive.Root>\n  );\n};\n \n \nconst BranchPicker = () => {\n  return (\n    <BranchPickerPrimitive.Root hideWhenSingleBranch>\n      <BranchPickerPrimitive.Previous />\n      <BranchPickerPrimitive.Number /> / <BranchPickerPrimitive.Count />\n      <BranchPickerPrimitive.Next />\n    </BranchPickerPrimitive.Root>\n  );\n};\nAPI\n\nYou can access the current branch state or navigate via the API as well.\nThese APIs rely on the message state and may only be called inside a message component.\n\nconst hasBranches = useMessageIf({ hasBranches: true }); // whether branchCount is >= 2\n \n// navigation\nconst goToNextBranch = useGoToNextBranch(); // null if there is no next branch\nconst goToPreviousBranch = useGoToPreviousBranch(); // null if there is no previous branch\n\nPrevious\n\nAttachments\n\nNext\n\nMessage Editing"
  },
  {
    "title": "Part 3: Approval UI | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/runtimes/langgraph/tutorial/part-3",
    "html": "LangGraph Cloud\nTutorial: Stockbroker\nPart 3: Approval UI\nBackground: LangGraph implementation details\n\nOur LangGraph backend interrupts the purchase_stock tool execution in order to ensure the user confirms the purchase. The user confirms the purchase by submitting a tool message with the approve field set to true.\n\nassistant-ui-stockbroker/backend/src/index.ts\nconst purchaseApproval = async (state: typeof GraphAnnotation.State) => {\n  const { messages } = state;\n  const lastMessage = messages[messages.length - 1];\n  if (!(lastMessage instanceof ToolMessage)) {\n    // Interrupt the node to request permission to execute the purchase.\n    throw new NodeInterrupt(\"Please confirm the purchase before executing.\");\n  }\n};\n \nconst shouldExecutePurchase = (state: typeof GraphAnnotation.State) => {\n  const { messages } = state;\n  const lastMessage = messages[messages.length - 1];\n  if (!(lastMessage instanceof ToolMessage)) {\n    // Interrupt the node to request permission to execute the purchase.\n    throw new NodeInterrupt(\"Please confirm the purchase before executing.\");\n  }\n \n  const { approve } = JSON.parse(lastMessage.content as string);\n  return approve ? \"execute_purchase\" : \"agent\";\n};\n \nconst workflow = new StateGraph(GraphAnnotation)\n  .addNode(\"agent\", callModel)\n  .addEdge(START, \"agent\")\n  .addNode(\"tools\", toolNode)\n  .addNode(\"prepare_purchase_details\", preparePurchaseDetails)\n  .addNode(\"purchase_approval\", purchaseApproval)\n  .addNode(\"execute_purchase\", executePurchase)\n  .addEdge(\"prepare_purchase_details\", \"purchase_approval\")\n  .addEdge(\"execute_purchase\", END)\n  .addEdge(\"tools\", \"agent\")\n  .addConditionalEdges(\"purchase_approval\", shouldExecutePurchase, [\n    \"agent\",\n    \"execute_purchase\",\n  ])\n  .addConditionalEdges(\"agent\", shouldContinue, [\n    \"tools\",\n    END,\n    \"prepare_purchase_details\",\n  ]);\nAdd approval UI\n\nWe create a new file under /components/tools/purchase-stock/PurchaseStockTool.tsx to define the tool.\n\nFirst, we define the tool arguments and result types:\n\n@/components/tools/purchase-stock/PurchaseStockTool.tsx\ntype PurchaseStockArgs = {\n  ticker: string;\n  companyName: string;\n  quantity: number;\n  maxPurchasePrice: number;\n};\n \ntype PurchaseStockResult = {\n  approve?: boolean;\n  cancelled?: boolean;\n  error?: string;\n};\n\nThen we use makeAssistantToolUI to define the tool UI:\n\n@/components/tools/purchase-stock/PurchaseStockTool.tsx\n\"use client\";\n \nimport { TransactionConfirmationPending } from \"./transaction-confirmation-pending\";\nimport { TransactionConfirmationFinal } from \"./transaction-confirmation-final\";\nimport { makeAssistantToolUI } from \"@assistant-ui/react\";\nimport { updateState } from \"@/lib/chatApi\";\n \nexport const PurchaseStockTool = makeAssistantToolUI<PurchaseStockArgs, string>(\n  {\n    toolName: \"purchase_stock\",\n    render: function PurchaseStockUI({ args, result, status, addResult }) {\n      const handleReject = async () => {\n        addResult({ approve: false });\n      };\n \n      const handleConfirm = async () => {\n        addResult({ approve: true });\n      };\n \n      return (\n        <div className=\"mb-4 flex flex-col items-center gap-2\">\n          <div>\n            <pre className=\"whitespace-pre-wrap break-all text-center\">\n              purchase_stock({JSON.stringify(args)})\n            </pre>\n          </div>\n          {!result && status.type !== \"running\" && (\n            <TransactionConfirmationPending\n              {...args}\n              onConfirm={handleConfirm}\n              onReject={handleReject}\n            />\n          )}\n        </div>\n      );\n    },\n  },\n);\n\nFinally, we add a TransactionConfirmationPending component to ask for approval.\n\nThis requires shadcn-ui's Card and Button components. We will install them as a dependency.\n\nnpx shadcn@latest add card button\n\nThen create a new file under /components/tools/purchase-stock/transaction-confirmation-pending.tsx to define the approval UI.\n\n@/components/tools/purchase-stock/transaction-confirmation-pending.tsx\n\"use client\";\n \nimport { CheckIcon, XIcon } from \"lucide-react\";\n \nimport { Button } from \"@/components/ui/button\";\nimport {\n  Card,\n  CardContent,\n  CardFooter,\n  CardHeader,\n  CardTitle,\n} from \"@/components/ui/card\";\n \ntype TransactionConfirmation = {\n  ticker: string;\n  companyName: string;\n  quantity: number;\n  maxPurchasePrice: number;\n  onConfirm: () => void;\n  onReject: () => void;\n};\n \nexport function TransactionConfirmationPending(props: TransactionConfirmation) {\n  const {\n    ticker,\n    companyName,\n    quantity,\n    maxPurchasePrice,\n    onConfirm,\n    onReject,\n  } = props;\n \n  return (\n    <Card className=\"mx-auto w-full max-w-md\">\n      <CardHeader>\n        <CardTitle className=\"text-2xl font-bold\">\n          Confirm Transaction\n        </CardTitle>\n      </CardHeader>\n      <CardContent className=\"space-y-4\">\n        <div className=\"grid grid-cols-2 gap-2\">\n          <p className=\"text-muted-foreground text-sm font-medium\">Ticker:</p>\n          <p className=\"text-sm font-bold\">{ticker}</p>\n          <p className=\"text-muted-foreground text-sm font-medium\">Company:</p>\n          <p className=\"text-sm\">{companyName}</p>\n          <p className=\"text-muted-foreground text-sm font-medium\">Quantity:</p>\n          <p className=\"text-sm\">{quantity} shares</p>\n          <p className=\"text-muted-foreground text-sm font-medium\">\n            Max Purchase Price:\n          </p>\n          <p className=\"text-sm\">${maxPurchasePrice?.toFixed(2)}</p>\n        </div>\n        <div className=\"bg-muted rounded-md p-3\">\n          <p className=\"text-sm font-medium\">Total Maximum Cost:</p>\n          <p className=\"text-lg font-bold\">\n            ${(quantity * maxPurchasePrice)?.toFixed(2)}\n          </p>\n        </div>\n      </CardContent>\n      <CardFooter className=\"flex justify-end\">\n        <Button variant=\"outline\" onClick={onReject}>\n          <XIcon className=\"mr-2 h-4 w-4\" />\n          Reject\n        </Button>\n        <Button onClick={onConfirm}>\n          <CheckIcon className=\"mr-2 h-4 w-4\" />\n          Confirm\n        </Button>\n      </CardFooter>\n    </Card>\n  );\n}\nBind approval UI\n@/app/page.tsx\nimport { PurchaseStockTool } from \"@/components/tools/purchase-stock/PurchaseStockTool\";\n \nexport default function Home() {\n  return (\n    <div className=\"flex h-full flex-col\">\n      <Thread\n        ...\n        tools={[PriceSnapshotTool, PurchaseStockTool]}\n      />\n    </div>\n  );\n}\nTry it out!\n\nAsk the assistant to buy 5 shares of Tesla. You should see the following appear:\n\nAdd TransactionConfirmationFinal to show approval result\n\nWe will add a component to display the approval result.\n\n@/components/tools/purchase-stock/transaction-confirmation-final.tsx\n\"use client\";\n \nimport { CheckCircle } from \"lucide-react\";\n \nimport { Card, CardContent, CardHeader, CardTitle } from \"@/components/ui/card\";\n \ntype TransactionConfirmation = {\n  ticker: string;\n  companyName: string;\n  quantity: number;\n  maxPurchasePrice: number;\n};\n \nexport function TransactionConfirmationFinal(props: TransactionConfirmation) {\n  const { ticker, companyName, quantity, maxPurchasePrice } = props;\n \n  return (\n    <Card className=\"mx-auto w-full max-w-md\">\n      <CardHeader className=\"text-center\">\n        <CheckCircle className=\"mx-auto mb-4 h-16 w-16 text-green-500\" />\n        <CardTitle className=\"text-2xl font-bold text-green-700\">\n          Transaction Confirmed\n        </CardTitle>\n      </CardHeader>\n      <CardContent className=\"space-y-4\">\n        <div className=\"rounded-md border border-green-200 bg-green-50 p-4\">\n          <h3 className=\"mb-2 text-lg font-semibold text-green-800\">\n            Purchase Summary\n          </h3>\n          <div className=\"grid grid-cols-2 gap-2 text-sm\">\n            <p className=\"font-medium text-green-700\">Ticker:</p>\n            <p className=\"font-bold text-green-900\">{ticker}</p>\n            <p className=\"font-medium text-green-700\">Company:</p>\n            <p className=\"text-green-900\">{companyName}</p>\n            <p className=\"font-medium text-green-700\">Quantity:</p>\n            <p className=\"text-green-900\">{quantity} shares</p>\n            <p className=\"font-medium text-green-700\">Price per Share:</p>\n            <p className=\"text-green-900\">${maxPurchasePrice?.toFixed(2)}</p>\n          </div>\n        </div>\n        <div className=\"rounded-md border border-green-300 bg-green-100 p-4\">\n          <p className=\"text-lg font-semibold text-green-800\">Total Cost:</p>\n          <p className=\"text-2xl font-bold text-green-900\">\n            ${(quantity * maxPurchasePrice)?.toFixed(2)}\n          </p>\n        </div>\n        <p className=\"text-center text-sm text-green-600\">\n          Your purchase of {quantity} shares of {companyName} ({ticker}) has\n          been successfully processed.\n        </p>\n      </CardContent>\n    </Card>\n  );\n}\nUpdate PurchaseStockTool\n\nWe will import the new <TransactionConfirmationFinal /> component and use it in the render function whenever an approval result is available.\n\n@/components/tools/purchase-stock/PurchaseStockTool.tsx\n\"use client\";\n \nimport { TransactionConfirmationPending } from \"./transaction-confirmation-pending\";\nimport { TransactionConfirmationFinal } from \"./transaction-confirmation-final\";\nimport { makeAssistantToolUI } from \"@assistant-ui/react\";\nimport { updateState } from \"@/lib/chatApi\";\n \ntype PurchaseStockArgs = {\n  ticker: string;\n  companyName: string;\n  quantity: number;\n  maxPurchasePrice: number;\n};\n \ntype PurchaseStockResult = {\n  approve?: boolean;\n  cancelled?: boolean;\n  error?: string;\n};\n \nexport const PurchaseStockTool = makeAssistantToolUI<PurchaseStockArgs, string>(\n  {\n    toolName: \"purchase_stock\",\n    render: function PurchaseStockUI({ args, result, status, addResult }) {\n      let resultObj: PurchaseStockResult;\n      try {\n        resultObj = result ? JSON.parse(result) : {};\n      } catch (e) {\n        resultObj = { error: result! };\n      }\n \n      const handleReject = () => {\n        addResult({ cancelled: true });\n      };\n \n      const handleConfirm = async () => {\n        addResult({ approve: true });\n      };\n \n      return (\n        <div className=\"mb-4 flex flex-col items-center gap-2\">\n          <div>\n            <pre className=\"whitespace-pre-wrap break-all text-center\">\n              purchase_stock({JSON.stringify(args)})\n            </pre>\n          </div>\n          {!result && status.type !== \"running\" && (\n            <TransactionConfirmationPending\n              {...args}\n              onConfirm={handleConfirm}\n              onReject={handleReject}\n            />\n          )}\n          {resultObj.approve && <TransactionConfirmationFinal {...args} />}\n          {resultObj.approve === false && (\n            <pre className=\"font-bold text-red-600\">User rejected purchase</pre>\n          )}\n          {resultObj.cancelled && (\n            <pre className=\"font-bold text-red-600\">Cancelled</pre>\n          )}\n        </div>\n      );\n    },\n  },\n);\nTry it out!\n\nConfirm the purchase of shares. You should see the approval confimration UI appear.\n\nPrevious\n\nPart 2: Generative UI\n\nNext\n\nLangChain LangServe"
  },
  {
    "title": "Introduction | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/runtimes/langgraph/tutorial/introduction",
    "html": "LangGraph Cloud\nTutorial: Stockbroker\nIntroduction\n\nIn this tutorial, we will build a stockbroker assistant using LangChain.js, LangGraph.js and assistant-ui.\n\nWe will go through the necessary steps to integrate assistant-ui with a LangGraph Cloud endpoint. Code snippets focus on the setup of the frontend, but we will highlight relevant sections of the backend code as well.\n\nThis agent leverages the following features:\n\nðŸš„ Streaming of messages from LangGraph state to assistant-ui\nðŸ’… Rich text rendering using Markdown\nðŸ› ï¸ Generative UI: Mapping tool calls to tool UIs\nðŸ” Approval UI: Confirming tool calls before execution (human-in-the-loop)\nPrerequisites\nNode.js 18.x or higher\nFinal Result\nDemo: https://assistant-ui-stockbroker.vercel.app/\nSource Code: https://github.com/Yonom/assistant-ui-stockbroker\nGet Started\n\nBegin Part 1 of the tutorial by setting up the frontend.\n\nPrevious\n\nIntroduction\n\nNext\n\nPart 1: Setup frontend"
  },
  {
    "title": "useChat Runtime | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/runtimes/vercel-ai-sdk/use-chat",
    "html": "Vercel AI SDK\nuseChat Runtime\nOverview\n\nIntegration with the Vercel AI SDK UI's useChat hook.\nIt allows integration with OpenAI, Anthropic, Mistral, Perplexity, AWS Bedrock, Azure, Google Gemini, Hugging Face, Fireworks, Cohere, LangChain, Replicate, Ollama, and more.\n\nGetting Started\nCreate a Next.JS project\nnpx create-next-app@latest my-app\ncd my-app\nInstall Vercel AI SDK and @assistant-ui/react\nnpm install @assistant-ui/react @assistant-ui/react-ai-sdk ai @ai-sdk/openai\nSetup a backend route under /api/chat\n\n@/app/api/chat/route.ts\n\nimport { openai } from \"@ai-sdk/openai\";\nimport { streamText } from \"ai\";\n \nexport const maxDuration = 30;\n \nexport async function POST(req: Request) {\n  const { messages } = await req.json();\n \n  const result = streamText({\n    model: openai(\"gpt-4o\"),\n    messages: convertToCoreMessages(messages),\n  });\n \n  return result.toDataStreamResponse();\n}\nDefine a MyRuntimeProvider component\n\n@/app/MyRuntimeProvider.tsx\n\n\"use client\";\n \nimport { useChat } from \"ai/react\";\nimport { AssistantRuntimeProvider } from \"@assistant-ui/react\";\nimport { useVercelUseChatRuntime } from \"@assistant-ui/react-ai-sdk\";\n \nexport function MyRuntimeProvider({\n  children,\n}: Readonly<{\n  children: React.ReactNode;\n}>) {\n  const chat = useChat({\n    api: \"/api/chat\",\n  });\n \n  const runtime = useVercelUseChatRuntime(chat);\n \n  return (\n    <AssistantRuntimeProvider runtime={runtime}>\n      {children}\n    </AssistantRuntimeProvider>\n  );\n}\nWrap your app in MyRuntimeProvider\n\n@/app/layout.tsx\n\nimport { MyRuntimeProvider } from '@/app/MyRuntimeProvider';\n \n...\n \nexport default function RootLayout({\n  children,\n}: Readonly<{\n  children: React.ReactNode;\n}>) {\n  return (\n    <MyRuntimeProvider>\n      <html lang=\"en\">\n        <body className={inter.className}>\n          {children}\n        </body>\n      </html>\n    </MyRuntimeProvider>\n  )\n}\n\nPrevious\n\nuseAssistant Runtime\n\nNext\n\nGetting Started"
  },
  {
    "title": "Vercel AI SDK RSC Runtime | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/runtimes/vercel-ai-sdk/rsc",
    "html": "Vercel AI SDK\nVercel AI SDK RSC Runtime\nOverview\n\nIntegration with the Vercel AI SDK React Server Components. It allows streaming React components directly from the server.\nIntegrates with OpenAI, Anthropic, Mistral, Perplexity, AWS Bedrock, Azure, Google Gemini, Hugging Face, Fireworks, Cohere, LangChain, Replicate, Ollama, and more.\n\nExample\n\nRSC Example App\n\nGetting Started\nCreate a Next.JS project\nnpx create-next-app@latest my-app\ncd my-app\nInstall Vercel AI SDK and @assistant-ui/react-ai-sdk\nnpm install @assistant-ui/react @assistant-ui/react-ai-sdk ai @ai-sdk/openai zod nanoid\nSetup actions.tsx\n\n@/app/actions.tsx\n\n\"use server\";\n \nimport { createAI, getMutableAIState, streamUI } from \"ai/rsc\";\nimport { openai } from \"@ai-sdk/openai\";\nimport { ReactNode } from \"react\";\nimport { z } from \"zod\";\nimport { nanoid } from \"nanoid\";\n \nexport interface ServerMessage {\n  role: \"user\" | \"assistant\";\n  content: string;\n}\n \nexport interface ClientMessage {\n  id: string;\n  role: \"user\" | \"assistant\";\n  display: ReactNode;\n}\n \nexport async function continueConversation(\n  input: string,\n): Promise<ClientMessage> {\n  \"use server\";\n \n  const history = getMutableAIState();\n \n  const result = await streamUI({\n    model: openai(\"gpt-3.5-turbo\"),\n    messages: [...history.get(), { role: \"user\", content: input }],\n    text: ({ content, done }) => {\n      if (done) {\n        history.done((messages: ServerMessage[]) => [\n          ...messages,\n          { role: \"assistant\", content },\n        ]);\n      }\n \n      return <div>{content}</div>;\n    },\n    tools: {\n      deploy: {\n        description: \"Deploy repository to vercel\",\n        parameters: z.object({\n          repositoryName: z\n            .string()\n            .describe(\"The name of the repository, example: vercel/ai-chatbot\"),\n        }),\n        generate: async function* ({ repositoryName }) {\n          yield <div>Cloning repository {repositoryName}...</div>;\n          await new Promise((resolve) => setTimeout(resolve, 3000));\n          yield <div>Building repository {repositoryName}...</div>;\n          await new Promise((resolve) => setTimeout(resolve, 2000));\n          return <div>{repositoryName} deployed!</div>;\n        },\n      },\n    },\n  });\n \n  return {\n    id: nanoid(),\n    role: \"assistant\",\n    display: result.value,\n  };\n}\n \nexport const AI = createAI<ServerMessage[], ClientMessage[]>({\n  actions: {\n    continueConversation,\n  },\n  initialAIState: [],\n  initialUIState: [],\n});\nDefine a MyRuntimeProvider component\n\n@/app/MyRuntimeProvider.tsx\n\n\"use client\";\n \nimport {\n  type AppendMessage,\n  AssistantRuntimeProvider,\n} from \"@assistant-ui/react\";\nimport { useVercelRSCRuntime } from \"@assistant-ui/react-ai-sdk\";\nimport { useActions, useUIState } from \"ai/rsc\";\nimport { nanoid } from \"nanoid\";\n \nimport type { AI } from \"./actions\";\n \nexport function MyRuntimeProvider({\n  children,\n}: Readonly<{\n  children: React.ReactNode;\n}>) {\n  const { continueConversation } = useActions();\n  const [messages, setMessages] = useUIState<typeof AI>();\n \n  const onNew = async (m: AppendMessage) => {\n    if (m.content[0]?.type !== \"text\")\n      throw new Error(\"Only text messages are supported\");\n \n    const input = m.content[0].text;\n    setMessages((currentConversation) => [\n      ...currentConversation,\n      { id: nanoid(), role: \"user\", display: input },\n    ]);\n \n    const message = await continueConversation(input);\n \n    setMessages((currentConversation) => [...currentConversation, message]);\n  };\n \n  const runtime = useVercelRSCRuntime({ messages, onNew });\n \n  return (\n    <AssistantRuntimeProvider runtime={runtime}>\n      {children}\n    </AssistantRuntimeProvider>\n  );\n}\nWrap your app in AI and MyRuntimeProvider\n\n@/app/layout.tsx\n\nimport { AI } from '@/app/actions';\nimport { MyRuntimeProvider } from '@/app/MyRuntimeProvider';\n \n...\n \nexport default function RootLayout({\n  children,\n}: Readonly<{\n  children: React.ReactNode;\n}>) {\n  return (\n    <AI>\n      <MyRuntimeProvider>\n        <html lang=\"en\">\n          <body className={inter.className}>\n            {children}\n          </body>\n        </html>\n      </MyRuntimeProvider>\n    </AI>\n  )\n}\n\nPrevious\n\nPicking a Runtime\n\nNext\n\nuseAssistant Runtime"
  },
  {
    "title": "ActionBar | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/ui/primitives/Attachment",
    "html": "Primitives\nActionBar\n\nButtons to interact with attachments.\n\nDual Use! Attachments can appear in both messages and composers.\n\nAnatomy\nimport { AttachmentPrimitive } from \"@assistant-ui/react\";\n \nconst MyMessageAttachment = () => (\n  <AttachmentPrimitive.Root>\n    <AttachmentPrimitive.Thumbnail />\n    <AttachmentPrimitive.Name />\n  </AttachmentPrimitive.Root>\n);\n \nconst MyComposerAttachment = () => (\n  <AttachmentPrimitive.Root>\n    <AttachmentPrimitive.Thumbnail />\n    <AttachmentPrimitive.Name />\n    <AttachmentPrimitive.Remove />\n  </AttachmentPrimitive.Root>\n);\nAPI Reference\nContainer\n\nContaints all parts of the attachment.\n\nThis primitive renders a <div> element unless asChild is set.\n\nAttachmentPrimitiveRootProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\nThumbnail\n\nThe thumbnail of the attachment.\n\nThis primitive renders a <div> element unless asChild is set.\n\nAttachmentPrimitiveThumbnailProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\nName\n\nThe name of the attachment.\n\nThis primitive renders a <div> element unless asChild is set.\n\nAttachmentPrimitiveNameProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\nRemove\n\nRemoves the attachment.\n\nThis primitive renders a <button> element unless asChild is set.\n\nAttachmentPrimitiveRemoveProps\nasChild:\nboolean = false\n\nChange the default rendered element for the one passed as a child, merging their props and behavior.\n\nRead the Composition guide for more details.\n\nPrevious\n\nContentPart\n\nNext\n\nPicking a Runtime"
  },
  {
    "title": "Thread | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/ui/styled/Thread",
    "html": "Styled Components\nThread\nOverview\n\nThe raw message list and message composer UI. Useful for full screen chat use cases.\n\nGetting Started\nImport CSS styles\n\nAdd the following to your tailwind.config.ts:\n\nTailwind\nTailwind + shadcn-ui\nNot using Tailwind\n/tailwind.config.ts\n{\n  plugins: [\n    require(\"tailwindcss-animate\"), // make sure to \"npm install tailwindcss-animate\"\n    require(\"@assistant-ui/react/tailwindcss\")({\n      components: [\"thread\"],\n    })\n  ],\n}\nUse it in your app\n/app/page.tsx\nimport { Thread, useEdgeRuntime } from \"@assistant-ui/react\";\n \nconst MyApp = () => {\n  const runtime = useEdgeRuntime({\n    api: \"/api/chat\",\n  });\n \n  return (\n    <div className=\"h-full\">\n      <Thread runtime={runtime} />\n    </div>\n  );\n};\n\nPrevious\n\nChoosing UI\n\nNext\n\nThread Width"
  },
  {
    "title": "<TextContentPartProvider /> | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/reference/TextContentPartProvider",
    "html": "Reference\n<TextContentPartProvider />\n\nThe TextContentPartProvider provides data and APIs for TextContentPart components.\n\nThis is useful if you want to reuse the same Text component outside of a message text, e.g. with the @assistant-ui/react-markdown package.\n\nimport { AssistantRuntimeProvider } from \"@assistant-ui/react\";\n \nconst MyApp = () => {\n  const runtime = useEdgeRuntime({ api: \"/api/chat\" });\n \n  return (\n    <TextContentPartProvider text={\"Hello!\"}>\n      <MyMarkdownText />\n    </AssistantRuntimeProvider>\n  );\n};\nProperties\nAssistantRuntimeProvider\nruntime:\nAssistantRuntime\n\nThe runtime to provide to the rest of your app.\n\nchildren?:\nReact.ReactNode\n\nPrevious\n\n<AssistantRuntimeProvider />\n\nNext\n\nChoosing UI"
  },
  {
    "title": "Attachments | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/guides/Attachments",
    "html": "Guides\nAttachments\n\nAllow the user to attach files to their messages.\n\nEnabling attachments\n\nIn order to enable attachments, you need to pass a AttachmentAdapter to the useEdgeRuntime hook.\n\nIn this example, we use a CompositeAttachmentAdapter that allows the user to attach images and text. The CompositeAttachmentAdapter allows you to combine multiple attachment adapters into one.\n\n/app/MyRuntimeProvider.tsx\nimport { useEdgeRuntime } from \"@assistant-ui/react\";\nimport {\n  CompositeAttachmentAdapter,\n  SimpleImageAttachmentAdapter,\n  SimpleTextAttachmentAdapter,\n} from \"@assistant-ui/react\";\n \nconst runtime = useEdgeRuntime({\n  api: \"/api/chat\",\n  adapters: {\n    attachments: new CompositeAttachmentAdapter([\n      new SimpleImageAttachmentAdapter(),\n      new SimpleTextAttachmentAdapter(),\n    ]),\n  },\n});\n\nPrevious\n\nGetting Started\n\nNext\n\nMessage Branching"
  },
  {
    "title": "Edge Runtime | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/runtimes/edge",
    "html": "Edge Runtime\nOverview\n\nThe Edge Runtime is assistant-ui's native runtime with the most built-in features. It is the recommended runtime for new projects.\n\nThe edge runtime can connect to a variety of backends, including:\n\nEdge Runtime backends\nVercel AI SDK backends (using Data Stream protocol)\nGetting Started\nCreate a Next.JS project\nnpx create-next-app@latest my-app\ncd my-app\nInstall @assistant-ui/react\nnpm install @assistant-ui/react\nDefine a MyRuntimeProvider component\n\nUpdate the MyModelAdapter below to integrate with your own custom API.\n\n@/app/MyRuntimeProvider.tsx\n\"use client\";\n \nimport type { ReactNode } from \"react\";\nimport {\n  AssistantRuntimeProvider,\n  useLocalRuntime,\n  type ChatModelAdapter,\n} from \"@assistant-ui/react\";\n \nconst MyModelAdapter: ChatModelAdapter = {\n  async run({ messages, abortSignal }) {\n    // TODO replace with your own API\n    const result = await fetch(\"<YOUR_API_ENDPOINT>\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      // forward the messages in the chat to the API\n      body: JSON.stringify({\n        messages,\n      }),\n      // if the user hits the \"cancel\" button or escape keyboard key, cancel the request\n      signal: abortSignal,\n    });\n \n    const data = await result.json();\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: data.text,\n        },\n      ],\n    };\n  },\n};\n \nexport function MyRuntimeProvider({\n  children,\n}: Readonly<{\n  children: ReactNode;\n}>) {\n  const runtime = useLocalRuntime(MyModelAdapter);\n \n  return (\n    <AssistantRuntimeProvider runtime={runtime}>\n      {children}\n    </AssistantRuntimeProvider>\n  );\n}\nWrap your app in MyRuntimeProvider\n@/app/layout.tsx\nimport type { ReactNode } from \"react\";\nimport { MyRuntimeProvider } from \"@/app/MyRuntimeProvider\";\n \nexport default function RootLayout({\n  children,\n}: Readonly<{\n  children: ReactNode;\n}>) {\n  return (\n    <MyRuntimeProvider>\n      <html lang=\"en\">\n        <body>{children}</body>\n      </html>\n    </MyRuntimeProvider>\n  );\n}\nStreaming\n\nDeclare the run function as an AsyncGenerator (async *run). This allows you to yield the results as they are generated.\n\n@/app/MyRuntimeProvider.tsx\nconst MyModelAdapter: ChatModelAdapter = {\n  async *run({ messages, abortSignal, config }) {\n    const stream = await backendApi({ messages, abortSignal, config });\n \n    let text = \"\";\n    for await (const part of stream) {\n      text += part.choices[0]?.delta?.content || \"\";\n \n      yield {\n        content: [{ type: \"text\", text }],\n      };\n    }\n  },\n};\n\nPrevious\n\nCustom REST API"
  },
  {
    "title": "Custom REST API | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/runtimes/custom-rest",
    "html": "Custom REST API\nOverview\n\nassistant-ui integrates with any custom REST API. To do so, you define a custom ChatModelAdapter and pass it to the useLocalRuntime hook.\n\nGetting Started\nCreate a Next.JS project\nnpx create-next-app@latest my-app\ncd my-app\nInstall @assistant-ui/react\nnpm install @assistant-ui/react\nDefine a MyRuntimeProvider component\n\nUpdate the MyModelAdapter below to integrate with your own custom API.\n\n@/app/MyRuntimeProvider.tsx\n\"use client\";\n \nimport type { ReactNode } from \"react\";\nimport {\n  AssistantRuntimeProvider,\n  useLocalRuntime,\n  type ChatModelAdapter,\n} from \"@assistant-ui/react\";\n \nconst MyModelAdapter: ChatModelAdapter = {\n  async run({ messages, abortSignal }) {\n    // TODO replace with your own API\n    const result = await fetch(\"<YOUR_API_ENDPOINT>\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      // forward the messages in the chat to the API\n      body: JSON.stringify({\n        messages,\n      }),\n      // if the user hits the \"cancel\" button or escape keyboard key, cancel the request\n      signal: abortSignal,\n    });\n \n    const data = await result.json();\n    return {\n      content: [\n        {\n          type: \"text\",\n          text: data.text,\n        },\n      ],\n    };\n  },\n};\n \nexport function MyRuntimeProvider({\n  children,\n}: Readonly<{\n  children: ReactNode;\n}>) {\n  const runtime = useLocalRuntime(MyModelAdapter);\n \n  return (\n    <AssistantRuntimeProvider runtime={runtime}>\n      {children}\n    </AssistantRuntimeProvider>\n  );\n}\nWrap your app in MyRuntimeProvider\n@/app/layout.tsx\nimport type { ReactNode } from \"react\";\nimport { MyRuntimeProvider } from \"@/app/MyRuntimeProvider\";\n \nexport default function RootLayout({\n  children,\n}: Readonly<{\n  children: ReactNode;\n}>) {\n  return (\n    <MyRuntimeProvider>\n      <html lang=\"en\">\n        <body>{children}</body>\n      </html>\n    </MyRuntimeProvider>\n  );\n}\nStreaming\n\nDeclare the run function as an AsyncGenerator (async *run). This allows you to yield the results as they are generated.\n\n@/app/MyRuntimeProvider.tsx\nconst MyModelAdapter: ChatModelAdapter = {\n  async *run({ messages, abortSignal, config }) {\n    const stream = await backendApi({ messages, abortSignal, config });\n \n    let text = \"\";\n    for await (const part of stream) {\n      text += part.choices[0]?.delta?.content || \"\";\n \n      yield {\n        content: [{ type: \"text\", text }],\n      };\n    }\n  },\n};\n\nPrevious\n\nExternal Store Runtime\n\nNext\n\nEdge Runtime"
  },
  {
    "title": "External Store Runtime | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/runtimes/external-store",
    "html": "External Store Runtime\nOverview\n\nUse the ExternalStoreRuntime if you want to manage the message state yourself via any react state management library.\n\nThis runtime requires a ExternalStoreAdapter<TMessage> handles communication between assistant-uiand your state. Unless you are storing messages as ThreadMessage, you need to define a convertMessage function to convert your messages to ThreadMessage.\n\n@/app/MyRuntimeProvider.tsx\nimport { useState, ReactNode } from \"react\";\nimport {\n  useExternalStoreRuntime,\n  ThreadMessageLike,\n  AppendMessage,\n  AssistantRuntimeProvider,\n} from \"@assistant-ui/react\";\n \nconst convertMessage = (message: MyMessage): ThreadMessageLike => {\n  return {\n    role: message.role,\n    content: [{ type: \"text\", text: message.content }],\n  };\n};\n \nexport function MyRuntimeProvider({\n  children,\n}: Readonly<{\n  children: ReactNode;\n}>) {\n  const [isRunning, setIsRunning] = useState(false);\n  const [messages, setMessages] = useState<MyMessage[]>([]);\n \n  const onNew = async (message: AppendMessage) => {\n    if (message.content[0]?.type !== \"text\")\n      throw new Error(\"Only text messages are supported\");\n \n    const input = message.content[0].text;\n    setMessages((currentConversation) => [\n      ...currentConversation,\n      { role: \"user\", content: input },\n    ]);\n \n    setIsRunning(true);\n    const assistantMessage = await backendApi(input);\n    setMessages((currentConversation) => [\n      ...currentConversation,\n      assistantMessage,\n    ]);\n    setIsRunning(false);\n  };\n \n  const runtime = useExternalStoreRuntime({\n    isRunning,\n    messages,\n    convertMessage,\n    onNew,\n  });\n \n  return (\n    <AssistantRuntimeProvider runtime={runtime}>\n      {children}\n    </AssistantRuntimeProvider>\n  );\n}\n\nPrevious\n\nTrieve Cloud\n\nNext\n\nCustom REST API"
  },
  {
    "title": "Trieve Cloud | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/runtimes/trieve",
    "html": "Trieve Cloud\nOverview\n\nIntegration with Trieve Cloud. You will need to get a Trieve Cloud account and set up a dataset to use this runtime at https://dashboard.trieve.ai.\n\nThis runtime will allow you to use Trieve Cloud to manage your assistant's responses, along with the ability to use Trieve's advanced features like tagging, filtering, analytics, and more.\n\nGetting Started\nCreate a Next.JS project\nnpx create-next-app@latest my-app\ncd my-app\nInstall trieve-ts-sdk, @assistant-ui/react-trieve and @assistant-ui/react\nnpm install @assistant-ui/react @assistant-ui/react-trieve trieve-ts-sdk\nSet up environment variables\n.env\nNEXT_PUBLIC_TRIEVE_API_URL=https://api.trieve.ai\nNEXT_PUBLIC_TRIEVE_API_KEY=\"tr-*********************\"\nNEXT_PUBLIC_TRIEVE_DATASET_ID=\"********-****-****-****-************\"\nSetup Trieve SDK\n@/app/trieve.tsx\n\"use client\";\n \nimport { TrieveSDK } from \"trieve-ts-sdk\";\n \nexport const trieve = new TrieveSDK({\n  baseUrl: process.env[\"NEXT_PUBLIC_TRIEVE_API_URL\"]!,\n  apiKey: process.env[\"NEXT_PUBLIC_TRIEVE_API_KEY\"]!,\n  datasetId: process.env[\"NEXT_PUBLIC_TRIEVE_DATASET_ID\"]!,\n});\nDefine a MyRuntimeProvider component\n@/app/MyRuntimeProvider.tsx\n\"use client\";\n \nimport { AssistantRuntimeProvider } from \"@assistant-ui/react\";\nimport { useTrieveRuntime } from \"@assistant-ui/react-trieve\";\nimport { trieve } from \"@/app/trieve\";\n \nexport const TrieveRuntimeProvider = () => {\n const runtime = useTrieveRuntime({\n    trieve,\n    // Define what you want to key the owners for threads on\n    ownerId: \"abcd\",\n    // Define tags that you want to use for filtering\n    tags: [\n      {\n        name: \"Stories\",\n        value: \"story\",\n      }\n    ],\n  });\n \n  return (\n    <AssistantRuntimeProvider runtime={runtime}>\n       {children}\n    </AssistantRuntimeProvider>\n  );\n};\nWrap your app in MyRuntimeProvider\n@/app/layout.tsx\nimport type { ReactNode } from \"react\";\nimport { TrieveRuntimeProvider } from \"@/app/MyRuntimeProvider\";\n \nexport default function RootLayout({\n  children,\n}: Readonly<{\n  children: ReactNode;\n}>) {\n  return (\n    <TrieveRuntimeProvider>\n      <html lang=\"en\">\n        <body>{children}</body>\n      </html>\n    </TrieveRuntimeProvider>\n  );\n}\nExample Usage\n@/app/layout.tsx\nimport { Thread } from \"@assistant-ui/react\";\nimport {\n  makeTrieveMarkdownText,\n  TrieveComposer,\n  TrieveThreadWelcome,\n  useTrieveExtras,\n} from \"@assistant-ui/react-trieve\";\n \nconst TrieveMarkdownText = makeTrieveMarkdownText();\n \nexport default function MyAssistant() {\n  const { title } = useTrieveExtras();\n \n  return (\n    <div className=\"flex h-full flex-col overflow-hidden pt-8\">\n      <p className=\"text-center text-xl font-bold\">{title}</p>\n      <div className=\"flex-grow overflow-hidden\">\n        <Thread\n          components={{\n            Composer: TrieveComposer,\n            ThreadWelcome: TrieveThreadWelcome,\n          }}\n          assistantMessage={{ components: { Text: TrieveMarkdownText } }}\n        />\n      </div>\n    </div>\n  );\n}\n\nPrevious\n\nLangChain LangServe\n\nNext\n\nExternal Store Runtime"
  },
  {
    "title": "LangChain LangServe | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/runtimes/langserve",
    "html": "LangChain LangServe\nOverview\n\nIntegration with a LangServe server via Vercel AI SDK.\n\nGetting Started\nCreate a Next.JS project\nnpx create-next-app@latest my-app\ncd my-app\nInstall @langchain/core, ai-sdk and @assistant-ui/react\nnpm install @assistant-ui/react @assistant-ui/react-ai-sdk ai ai/react @langchain/core\nSetup a backend route under /api/chat\n@/app/api/chat/route.ts\nimport { RemoteRunnable } from \"@langchain/core/runnables/remote\";\nimport type { RunnableConfig } from \"@langchain/core/runnables\";\nimport { streamText, LangChainAdapter, type Message } from \"ai\";\n \nexport const maxDuration = 30;\n \nexport async function POST(req: Request) {\n  const { messages } = (await req.json()) as { messages: Message[] };\n \n  // TODO replace with your own langserve URL\n  const remoteChain = new RemoteRunnable<\n    { messages: Message[] },\n    string,\n    RunnableConfig\n  >({\n    url: \"<YOUR_LANGSERVE_URL>\",\n  });\n \n  const stream = await remoteChain.stream({\n    messages,\n  });\n \n  return LangChainAdapter.toDataStreamResponse(stream);\n}\nDefine a MyRuntimeProvider component\n@/app/MyRuntimeProvider.tsx\n\"use client\";\n \nimport { useChat } from \"ai/react\";\nimport { AssistantRuntimeProvider } from \"@assistant-ui/react\";\nimport { useVercelUseChatRuntime } from \"@assistant-ui/react-ai-sdk\";\n \nexport function MyRuntimeProvider({\n  children,\n}: Readonly<{\n  children: React.ReactNode;\n}>) {\n  const chat = useChat({\n    api: \"/api/chat\",\n    unstable_AISDKInterop: true,\n  });\n \n  const runtime = useVercelUseChatRuntime(chat);\n \n  return (\n    <AssistantRuntimeProvider runtime={runtime}>\n      {children}\n    </AssistantRuntimeProvider>\n  );\n}\nWrap your app in MyRuntimeProvider\n@/app/layout.tsx\nimport type { ReactNode } from \"react\";\nimport { MyRuntimeProvider } from \"@/app/MyRuntimeProvider\";\n \nexport default function RootLayout({\n  children,\n}: Readonly<{\n  children: ReactNode;\n}>) {\n  return (\n    <MyRuntimeProvider>\n      <html lang=\"en\">\n        <body>{children}</body>\n      </html>\n    </MyRuntimeProvider>\n  );\n}\n\nPrevious\n\nPart 3: Approval UI\n\nNext\n\nTrieve Cloud"
  },
  {
    "title": "Getting Started | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/runtimes/langgraph",
    "html": "Getting Started\nRequirements\n\nYou need a LangGraph Cloud API server. You can start a server locally via LangGraph Studio or use LangSmith for a hosted version.\n\nThe state of the graph you are using must have a messages key with a list of LangChain-alike messages.\n\nNew project from template\nCreate a new project based on the LangGraph assistant-ui template\nnpx create-assistant-ui@latest -t langgraph my-app\nSet environment variables\n\nCreate a .env.local file in your project with the following variables:\n\n# LANGCHAIN_API_KEY=your_api_key # for production\n# LANGGRAPH_API_URL=your_api_url # for production\nNEXT_PUBLIC_LANGGRAPH_API_URL=your_api_url # for development (no api key required)\nNEXT_PUBLIC_LANGGRAPH_ASSISTANT_ID=your_graph_id\nInstallation in existing React project\nInstall dependencies\nnpm install @assistant-ui/react @assistant-ui/react-langgraph @langchain/langgraph-sdk\nSetup a proxy backend endpoint (optional, for production)\n\nThis example forwards every request to the LangGraph server directly from the browser. For production use-cases, you should limit the API calls to the subset of endpoints that you need and perform authorization checks.\n\n@/api/api/[...path]/route.ts\nimport { NextRequest, NextResponse } from \"next/server\";\n \nexport const runtime = \"edge\";\n \nfunction getCorsHeaders() {\n  return {\n    \"Access-Control-Allow-Origin\": \"*\",\n    \"Access-Control-Allow-Methods\": \"GET, POST, PUT, PATCH, DELETE, OPTIONS\",\n    \"Access-Control-Allow-Headers\": \"*\",\n  };\n}\n \nasync function handleRequest(req: NextRequest, method: string) {\n  try {\n    const path = req.nextUrl.pathname.replace(/^\\/?api\\//, \"\");\n    const url = new URL(req.url);\n    const searchParams = new URLSearchParams(url.search);\n    searchParams.delete(\"_path\");\n    searchParams.delete(\"nxtP_path\");\n    const queryString = searchParams.toString()\n      ? `?${searchParams.toString()}`\n      : \"\";\n \n    const options: RequestInit = {\n      method,\n      headers: {\n        \"x-api-key\": process.env[\"LANGCHAIN_API_KEY\"] || \"\",\n      },\n    };\n \n    if ([\"POST\", \"PUT\", \"PATCH\"].includes(method)) {\n      options.body = await req.text();\n    }\n \n    const res = await fetch(\n      `${process.env[\"LANGGRAPH_API_URL\"]}/${path}${queryString}`,\n      options,\n    );\n \n    return new NextResponse(res.body, {\n      status: res.status,\n      statusText: res.statusText,\n      headers: {\n        ...res.headers,\n        ...getCorsHeaders(),\n      },\n    });\n  } catch (e: any) {\n    return NextResponse.json({ error: e.message }, { status: e.status ?? 500 });\n  }\n}\n \nexport const GET = (req: NextRequest) => handleRequest(req, \"GET\");\nexport const POST = (req: NextRequest) => handleRequest(req, \"POST\");\nexport const PUT = (req: NextRequest) => handleRequest(req, \"PUT\");\nexport const PATCH = (req: NextRequest) => handleRequest(req, \"PATCH\");\nexport const DELETE = (req: NextRequest) => handleRequest(req, \"DELETE\");\n \n// Add a new OPTIONS handler\nexport const OPTIONS = () => {\n  return new NextResponse(null, {\n    status: 204,\n    headers: {\n      ...getCorsHeaders(),\n    },\n  });\n};\nSetup helper functions\n@/lib/chatApi.ts\nimport { Client } from \"@langchain/langgraph-sdk\";\nimport { LangChainMessage } from \"@assistant-ui/react-langgraph\";\n \nconst createClient = () => {\n  const apiUrl = process.env[\"NEXT_PUBLIC_LANGGRAPH_API_URL\"] || \"/api\";\n  return new Client({\n    apiUrl,\n  });\n};\n \nexport const createThread = async () => {\n  const client = createClient();\n  return client.threads.create();\n};\n \nexport const getThreadState = async (\n  threadId: string,\n): Promise<ThreadState<{ messages: LangChainMessage[] }>> => {\n  const client = createClient();\n  return client.threads.getState(threadId);\n};\n \nexport const sendMessage = async (params: {\n  threadId: string;\n  messages: LangChainMessage;\n}) => {\n  const client = createClient();\n  return client.runs.stream(\n    params.threadId,\n    process.env[\"NEXT_PUBLIC_LANGGRAPH_ASSISTANT_ID\"]!,\n    {\n      input: {\n        messages: params.messages,\n      },\n      streamMode: \"messages\",\n    },\n  );\n};\nDefine a MyAssistant component\n@/components/MyAssistant.tsx\n\"use client\";\n \nimport { useRef } from \"react\";\nimport { Thread } from \"@assistant-ui/react\";\nimport { useLangGraphRuntime } from \"@assistant-ui/react-langgraph\";\nimport { makeMarkdownText } from \"@assistant-ui/react-markdown\";\n \nimport { createThread, getThreadState, sendMessage } from \"@/lib/chatApi\";\n \nconst MarkdownText = makeMarkdownText();\n \nexport function MyAssistant() {\n  const threadIdRef = useRef<string | undefined>();\n  const runtime = useLangGraphRuntime({\n    threadId: threadIdRef.current,\n    stream: async (messages) => {\n      if (!threadIdRef.current) {\n        const { thread_id } = await createThread();\n        threadIdRef.current = thread_id;\n      }\n      const threadId = threadIdRef.current;\n      return sendMessage({\n        threadId,\n        messages,\n      });\n    },\n    onSwitchToNewThread: async () => {\n      const { thread_id } = await createThread();\n      threadIdRef.current = thread_id;\n    },\n    onSwitchToThread: async (threadId) => {\n      const state = await getThreadState(threadId);\n      threadIdRef.current = threadId;\n      return { messages: state.values.messages };\n    },\n  });\n \n  return (\n    <Thread\n      runtime={runtime}\n      assistantMessage={{ components: { Text: MarkdownText } }}\n    />\n  );\n}\nUse the MyAssistant component\n@/app/page.tsx\nimport { MyAssistant } from \"@/components/MyAssistant\";\n \nexport default function Home() {\n  return (\n    <main className=\"h-dvh\">\n      <MyAssistant />\n    </main>\n  );\n}\nSetup environment variables\n\nCreate a .env.local file in your project with the following variables:\n\n# LANGCHAIN_API_KEY=your_api_key # for production\n# LANGGRAPH_API_URL=your_api_url # for production\nNEXT_PUBLIC_LANGGRAPH_API_URL=your_api_url # for development (no api key required)\nNEXT_PUBLIC_LANGGRAPH_ASSISTANT_ID=your_graph_id\nSetup UI components\n\nFollow the UI Components guide to setup the UI components.\n\nPrevious\n\nuseChat Runtime\n\nNext\n\nGetting Started"
  },
  {
    "title": "Picking a Runtime | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/runtimes/pick-a-runtime",
    "html": "Picking a Runtime\n\nassistant-ui offers a variety of runtimes for different use cases.\n\nNew Chatbot\n\nThe following runtimes are recommended for new apps:\n\nEdge\nLangGraph Cloud\nTrieve\nEdge Runtime\n\nThe Edge Runtime is assistant-ui's native runtime.\n\nLangGraph Cloud\n\nThe LangGraph Cloud runtime lets you build stateful agents with LangGraph.\n\nTrieve\n\nBuild chatbots that can interact with your content with Trieve.ai, one of the most powerful RAG APIs.\n\nVercel AI SDK\n\nIf you are already using the Vercel AI SDK, there are four ways to integrate:\n\nEdge Runtime with Data Stream Protocol\n[useChat Runtime]\n[useAssistant Runtime]\n[RSC Runtime]\nAlready using one of our supported backends\n\nWe have native integrations for the following backends:\n\nLangGraph\nTrieve\nVercel AI SDK\nAlready using a custom backend\n\nFor custom backends, we have two entrypoints for integration:\n\nCustom REST API\nExternal Store\n\nPrevious\n\nActionBar\n\nNext\n\nVercel AI SDK RSC Runtime"
  },
  {
    "title": "Choosing UI | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/ui/choosing-ui",
    "html": "Choosing UI\n\nThere are two routes for integrating the UI components:\n\nStyled Components (import styled components from @assistant-ui/react)\nPrimitives + shadcn-ui CLI (paste a thread.tsx file in your repository)\nStyled Components\n\nImport styled components from @assistant-ui/react. The is recommended for most use cases.\n\nPrimitives + shadcn-ui CLI\n\nshadcn-ui CLI pastes a thread.tsx file (> 250 lines of code) in your repository.\n\nThis makes use of assistant-ui's Primitives. These provide the functionality, but contain no styling. Styling lives entirely in your repository, while functionality is handled by the @assistant-ui/react library.\n\nExample excerpt from the thread.tsx template:\n\n...\n<MessagePrimitive.Root className=\"grid w-full max-w-2xl auto-rows-auto grid-cols-[minmax(72px,1fr)_auto] gap-y-2 py-4\">\n  <ActionBarPrimitive.Root\n    hideWhenRunning\n    autohide=\"not-last\"\n    className=\"col-start-1 mr-3 mt-2.5 flex flex-col items-end\"\n  >\n    <ActionBarPrimitive.Edit asChild>\n      ...\n    </ActionBarPrimitive.Edit>\n  </ActionBarPrimitive.Root>\n \n  <div className=\"bg-muted text-foreground col-start-2 row-start-1 max-w-xl break-words rounded-3xl px-5 py-2.5\">\n    <MessagePrimitive.Content />\n  </div>\n...\nHow to decide\n\nIf you want to start with the default assistant-ui look and feel, use Styled Components. If you want to completely change the UI from the get-go, use shadcn-ui.\n\nThe Styled Components method receives automatic CSS style updates/bug fixes. The shadcn-ui method requires you to manually update the CSS styles.\n\nBoth methods receive functionality updates and bug fixes via the Primitives. Both methods are fully customizable. As you customize the Styled Components through a process called Decomposition, your file will slowly look very similar to thread.tsx from the shadcn-ui CLI template.\n\nPrevious\n\n<TextContentPartProvider />\n\nNext\n\nThread"
  },
  {
    "title": "Getting Started | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/getting-started",
    "html": "Getting Started\nStart with a new project\n\nCreate a new project\n\nCreate a new project with assistant-ui pre-configured:\n\nnpx create-assistant-ui@latest my-app\ncd my-app\nAdd API key\n\nAdd a new .env file to your project with your OpenAI API key:\n\nOPENAI_API_KEY=\"sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\nStart the app\nnpm run dev\nInstall in an existing app\nInstall @assistant-ui/react\nnpm install @assistant-ui/react\nSetup Backend Endpoint\n\nInstall provider SDK:\n\nOpenAI\nAnthropic\nAWS\nAzure\nGemini\nGCP\nGroq\nFireworks\nCohere\nOllama\nChrome AI\nTerminal\nnpm install @ai-sdk/openai\n\nAdd an API endpoint:\n\nOpenAI\nAnthropic\nAzure\nAWS\nGemini\nGCP\nGroq\nFireworks\nCohere\nOllama\nChrome AI\n/app/api/chat/route.ts\nimport { openai } from \"@ai-sdk/openai\";\nimport { createEdgeRuntimeAPI } from \"@assistant-ui/react/edge\";\n \nexport const { POST } = createEdgeRuntimeAPI({\n  model: openai(\"gpt-4o\"),\n});\n\nDefine environment variables:\n\nOpenAI\nAnthropic\nAWS\nAzure\nGemini\nGCP\nGroq\nFireworks\nCohere\nOllama\nChrome AI\n/.env.local\nOPENAI_API_KEY=\"sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n\nIf you aren't using Next.js, you can also deploy this endpoint to Cloudflare Workers, or any other serverless platform.\n\nImport CSS styles\n\nAdd the following to your tailwind.config.ts:\n\nTailwind\nTailwind + shadcn-ui\nNot using Tailwind\n/tailwind.config.ts\n{\n  plugins: [\n    require(\"tailwindcss-animate\"), // make sure to \"npm install tailwindcss-animate\"\n    require(\"@assistant-ui/react/tailwindcss\")\n  ],\n}\nUse it in your app\nThread\nAssistantModal\n/app/page.tsx\nimport { Thread, useEdgeRuntime } from \"@assistant-ui/react\";\n \nconst MyApp = () => {\n  const runtime = useEdgeRuntime({\n    api: \"/api/chat\",\n  });\n \n  return (\n    <div className=\"h-full\">\n      <Thread runtime={runtime} />\n    </div>\n  );\n};\n\nNext\n\nAttachments"
  },
  {
    "title": "Getting Started | assistant-ui",
    "url": "https://www.assistant-ui.com/docs/getting-started",
    "html": "Getting Started\nStart with a new project\n\nCreate a new project\n\nCreate a new project with assistant-ui pre-configured:\n\nnpx create-assistant-ui@latest my-app\ncd my-app\nAdd API key\n\nAdd a new .env file to your project with your OpenAI API key:\n\nOPENAI_API_KEY=\"sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\nStart the app\nnpm run dev\nInstall in an existing app\nInstall @assistant-ui/react\nnpm install @assistant-ui/react\nSetup Backend Endpoint\n\nInstall provider SDK:\n\nOpenAI\nAnthropic\nAWS\nAzure\nGemini\nGCP\nGroq\nFireworks\nCohere\nOllama\nChrome AI\nTerminal\nnpm install @ai-sdk/openai\n\nAdd an API endpoint:\n\nOpenAI\nAnthropic\nAzure\nAWS\nGemini\nGCP\nGroq\nFireworks\nCohere\nOllama\nChrome AI\n/app/api/chat/route.ts\nimport { openai } from \"@ai-sdk/openai\";\nimport { createEdgeRuntimeAPI } from \"@assistant-ui/react/edge\";\n \nexport const { POST } = createEdgeRuntimeAPI({\n  model: openai(\"gpt-4o\"),\n});\n\nDefine environment variables:\n\nOpenAI\nAnthropic\nAWS\nAzure\nGemini\nGCP\nGroq\nFireworks\nCohere\nOllama\nChrome AI\n/.env.local\nOPENAI_API_KEY=\"sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\"\n\nIf you aren't using Next.js, you can also deploy this endpoint to Cloudflare Workers, or any other serverless platform.\n\nImport CSS styles\n\nAdd the following to your tailwind.config.ts:\n\nTailwind\nTailwind + shadcn-ui\nNot using Tailwind\n/tailwind.config.ts\n{\n  plugins: [\n    require(\"tailwindcss-animate\"), // make sure to \"npm install tailwindcss-animate\"\n    require(\"@assistant-ui/react/tailwindcss\")\n  ],\n}\nUse it in your app\nThread\nAssistantModal\n/app/page.tsx\nimport { Thread, useEdgeRuntime } from \"@assistant-ui/react\";\n \nconst MyApp = () => {\n  const runtime = useEdgeRuntime({\n    api: \"/api/chat\",\n  });\n \n  return (\n    <div className=\"h-full\">\n      <Thread runtime={runtime} />\n    </div>\n  );\n};\n\nNext\n\nAttachments"
  }
]